<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `Modbus` struct in crate `libmodbus_rs`.">
    <meta name="keywords" content="rust, rustlang, rust-lang, Modbus">

    <title>libmodbus_rs::Modbus - Rust</title>

    <link rel="stylesheet" type="text/css" href="../normalize.css">
    <link rel="stylesheet" type="text/css" href="../rustdoc.css">
    <link rel="stylesheet" type="text/css" href="../main.css">
    

    <link rel="shortcut icon" href="https://zzeroo.github.io/share/favicon.ico">
    
</head>
<body class="rustdoc struct">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <nav class="sidebar">
        <a href='../libmodbus_rs/index.html'><img src='https://zzeroo.github.io/share/zzeroo-logo.png' alt='logo' width='100'></a>
        <p class='location'>Struct Modbus</p><div class="block items"><ul><li><a href="#fields">Fields</a></li><li><a href="#methods">Methods</a></li><li><a href="#implementations">Trait Implementations</a></li></ul></div><p class='location'><a href='index.html'>libmodbus_rs</a></p><script>window.sidebarCurrent = {name: 'Modbus', ty: 'struct', relpath: ''};</script><script defer src="sidebar-items.js"></script>
    </nav>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press ‘S’ to search, ‘?’ for more options…"
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content">
<h1 class='fqn'><span class='in-band'>Struct <a href='index.html'>libmodbus_rs</a>::<wbr><a class="struct" href=''>Modbus</a></span><span class='out-of-band'><span id='render-detail'>
                   <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">
                       [<span class='inner'>&#x2212;</span>]
                   </a>
               </span><a class='srclink' href='../src/libmodbus_rs/modbus.rs.html#104-106' title='goto source code'>[src]</a></span></h1>
<pre class='rust struct'>pub struct Modbus {
    pub ctx: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html">*mut </a><a class="type" href="../libmodbus_sys/type.modbus_t.html" title="type libmodbus_sys::modbus_t">modbus_t</a>,
}</pre><div class='docblock'><p>Safe interface for <a href="http://libmodbus.org">libmodbus</a></p>

<p>The different parts of libmodbus are implemented as traits. The modules of this crate contains these
traits and a implementation with a, hopefully safe, interface.</p>
</div><h2 id='fields' class='fields small-section-header'>
                       Fields<a href='#fields' class='anchor'></a></h2><span id="structfield.ctx" class="structfield small-section-header">
                           <a href="#structfield.ctx" class="anchor field"></a>
                           <span id="ctx.v" class='invisible'>
                           <code>ctx: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html">*mut </a><a class="type" href="../libmodbus_sys/type.modbus_t.html" title="type libmodbus_sys::modbus_t">modbus_t</a></code>
                           </span></span>
                    <h2 id='methods' class='small-section-header'>
                      Methods<a href='#methods' class='anchor'></a>
                    </h2>
                <h3 id='impl' class='impl'><span class='in-band'><code>impl <a class="struct" href="../libmodbus_rs/struct.Modbus.html" title="struct libmodbus_rs::Modbus">Modbus</a></code><a href='#impl' class='anchor'></a></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/libmodbus_rs/modbus.rs.html#108-635' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='associatedconstant.ENOBASE' class="associatedconstant"><span id='ENOBASE.v' class='invisible'><code>const <a href='#associatedconstant.ENOBASE' class="constant"><b>ENOBASE</b></a>: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a></code></span></h4>
<div class='docblock'><pre class="rust ">
<span class="ident">ENOBASE</span>: <span class="ident">u32</span> <span class="op">=</span> <span class="ident">ffi</span>::<span class="ident">MODBUS_ENOBASE</span></pre>
</div><h4 id='associatedconstant.MAX_ADU_LENGTH' class="associatedconstant"><span id='MAX_ADU_LENGTH.v' class='invisible'><code>const <a href='#associatedconstant.MAX_ADU_LENGTH' class="constant"><b>MAX_ADU_LENGTH</b></a>: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></code></span></h4>
<div class='docblock'><pre class="rust ">
<span class="ident">MAX_ADU_LENGTH</span>: <span class="ident">usize</span> <span class="op">=</span> <span class="ident">ffi</span>::<span class="ident">MODBUS_MAX_ADU_LENGTH</span> <span class="kw">as</span> <span class="ident">usize</span></pre>
</div><h4 id='associatedconstant.MAX_PDU_LENGTH' class="associatedconstant"><span id='MAX_PDU_LENGTH.v' class='invisible'><code>const <a href='#associatedconstant.MAX_PDU_LENGTH' class="constant"><b>MAX_PDU_LENGTH</b></a>: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></code></span></h4>
<div class='docblock'><pre class="rust ">
<span class="ident">MAX_PDU_LENGTH</span>: <span class="ident">usize</span> <span class="op">=</span> <span class="ident">ffi</span>::<span class="ident">MODBUS_MAX_PDU_LENGTH</span> <span class="kw">as</span> <span class="ident">usize</span></pre>
</div><h4 id='associatedconstant.MAX_READ_BITS' class="associatedconstant"><span id='MAX_READ_BITS.v' class='invisible'><code>const <a href='#associatedconstant.MAX_READ_BITS' class="constant"><b>MAX_READ_BITS</b></a>: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></code></span></h4>
<div class='docblock'><pre class="rust ">
<span class="ident">MAX_READ_BITS</span>: <span class="ident">usize</span> <span class="op">=</span> <span class="ident">ffi</span>::<span class="ident">MODBUS_MAX_READ_BITS</span> <span class="kw">as</span> <span class="ident">usize</span></pre>
</div><h4 id='associatedconstant.MAX_READ_REGISTERS' class="associatedconstant"><span id='MAX_READ_REGISTERS.v' class='invisible'><code>const <a href='#associatedconstant.MAX_READ_REGISTERS' class="constant"><b>MAX_READ_REGISTERS</b></a>: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></code></span></h4>
<div class='docblock'><pre class="rust ">
<span class="ident">MAX_READ_REGISTERS</span>: <span class="ident">usize</span> <span class="op">=</span> <span class="ident">ffi</span>::<span class="ident">MODBUS_MAX_READ_REGISTERS</span> <span class="kw">as</span> <span class="ident">usize</span></pre>
</div><h4 id='associatedconstant.MAX_WR_READ_REGISTERS' class="associatedconstant"><span id='MAX_WR_READ_REGISTERS.v' class='invisible'><code>const <a href='#associatedconstant.MAX_WR_READ_REGISTERS' class="constant"><b>MAX_WR_READ_REGISTERS</b></a>: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></code></span></h4>
<div class='docblock'><pre class="rust ">
<span class="ident">MAX_WR_READ_REGISTERS</span>: <span class="ident">usize</span> <span class="op">=</span> <span class="ident">ffi</span>::<span class="ident">MODBUS_MAX_WR_READ_REGISTERS</span> <span class="kw">as</span> <span class="ident">usize</span></pre>
</div><h4 id='associatedconstant.MAX_WR_WRITE_REGISTERS' class="associatedconstant"><span id='MAX_WR_WRITE_REGISTERS.v' class='invisible'><code>const <a href='#associatedconstant.MAX_WR_WRITE_REGISTERS' class="constant"><b>MAX_WR_WRITE_REGISTERS</b></a>: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></code></span></h4>
<div class='docblock'><pre class="rust ">
<span class="ident">MAX_WR_WRITE_REGISTERS</span>: <span class="ident">usize</span> <span class="op">=</span> <span class="ident">ffi</span>::<span class="ident">MODBUS_MAX_WR_WRITE_REGISTERS</span> <span class="kw">as</span> <span class="ident">usize</span></pre>
</div><h4 id='associatedconstant.MAX_WRITE_BITS' class="associatedconstant"><span id='MAX_WRITE_BITS.v' class='invisible'><code>const <a href='#associatedconstant.MAX_WRITE_BITS' class="constant"><b>MAX_WRITE_BITS</b></a>: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></code></span></h4>
<div class='docblock'><pre class="rust ">
<span class="ident">MAX_WRITE_BITS</span>: <span class="ident">usize</span> <span class="op">=</span> <span class="ident">ffi</span>::<span class="ident">MODBUS_MAX_WRITE_BITS</span> <span class="kw">as</span> <span class="ident">usize</span></pre>
</div><h4 id='associatedconstant.MAX_WRITE_REGISTERS' class="associatedconstant"><span id='MAX_WRITE_REGISTERS.v' class='invisible'><code>const <a href='#associatedconstant.MAX_WRITE_REGISTERS' class="constant"><b>MAX_WRITE_REGISTERS</b></a>: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></code></span></h4>
<div class='docblock'><pre class="rust ">
<span class="ident">MAX_WRITE_REGISTERS</span>: <span class="ident">usize</span> <span class="op">=</span> <span class="ident">ffi</span>::<span class="ident">MODBUS_MAX_WRITE_REGISTERS</span> <span class="kw">as</span> <span class="ident">usize</span></pre>
</div><h4 id='associatedconstant.RTU_MAX_ADU_LENGTH' class="associatedconstant"><span id='RTU_MAX_ADU_LENGTH.v' class='invisible'><code>const <a href='#associatedconstant.RTU_MAX_ADU_LENGTH' class="constant"><b>RTU_MAX_ADU_LENGTH</b></a>: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></code></span></h4>
<div class='docblock'><pre class="rust ">
<span class="ident">RTU_MAX_ADU_LENGTH</span>: <span class="ident">usize</span> <span class="op">=</span> <span class="ident">ffi</span>::<span class="ident">MODBUS_RTU_MAX_ADU_LENGTH</span> <span class="kw">as</span> <span class="ident">usize</span></pre>
</div><h4 id='associatedconstant.TCP_DEFAULT_PORT' class="associatedconstant"><span id='TCP_DEFAULT_PORT.v' class='invisible'><code>const <a href='#associatedconstant.TCP_DEFAULT_PORT' class="constant"><b>TCP_DEFAULT_PORT</b></a>: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a></code></span></h4>
<div class='docblock'><pre class="rust ">
<span class="ident">TCP_DEFAULT_PORT</span>: <span class="ident">u32</span> <span class="op">=</span> <span class="ident">ffi</span>::<span class="ident">MODBUS_TCP_DEFAULT_PORT</span></pre>
</div><h4 id='associatedconstant.TCP_MAX_ADU_LENGTH' class="associatedconstant"><span id='TCP_MAX_ADU_LENGTH.v' class='invisible'><code>const <a href='#associatedconstant.TCP_MAX_ADU_LENGTH' class="constant"><b>TCP_MAX_ADU_LENGTH</b></a>: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a></code></span></h4>
<div class='docblock'><pre class="rust ">
<span class="ident">TCP_MAX_ADU_LENGTH</span>: <span class="ident">u32</span> <span class="op">=</span> <span class="ident">ffi</span>::<span class="ident">MODBUS_TCP_MAX_ADU_LENGTH</span></pre>
</div><h4 id='associatedconstant.TCP_SLAVE' class="associatedconstant"><span id='TCP_SLAVE.v' class='invisible'><code>const <a href='#associatedconstant.TCP_SLAVE' class="constant"><b>TCP_SLAVE</b></a>: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a></code></span></h4>
<div class='docblock'><pre class="rust ">
<span class="ident">TCP_SLAVE</span>: <span class="ident">u32</span> <span class="op">=</span> <span class="ident">ffi</span>::<span class="ident">MODBUS_TCP_SLAVE</span></pre>
</div><h4 id='method.connect' class="method"><span id='connect.v' class='invisible'><code>pub fn <a href='#method.connect' class='fnname'>connect</a>(&amp;self) -&gt; <a class="type" href="../libmodbus_rs/errors/type.Result.html" title="type libmodbus_rs::errors::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">()</a>&gt;</code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/libmodbus_rs/modbus.rs.html#147-155' title='goto source code'>[src]</a></span></h4>
<div class='docblock'><p><code>connect</code> - establish a Modbus connection</p>

<p>The <a href="#method.connect"><code>connect()</code></a> function shall establish a connection to a Modbus server,
a network or a bus.</p>

<h1 id='return-value' class='section-header'><a href='#return-value'>Return value</a></h1>
<p>The function return an OK Result if successful. Otherwise it contains an Error.</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">libmodbus_rs</span>::{<span class="ident">Modbus</span>, <span class="ident">ModbusTCP</span>};

<span class="comment">// create server</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">server</span> <span class="op">=</span> <span class="ident">Modbus</span>::<span class="ident">new_tcp</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">1502</span>).<span class="ident">unwrap</span>();
<span class="comment">// create client</span>
<span class="kw">let</span> <span class="ident">client</span> <span class="op">=</span> <span class="ident">Modbus</span>::<span class="ident">new_tcp</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">1502</span>).<span class="ident">unwrap</span>();
<span class="comment">// start server in listen mode</span>
<span class="kw">let</span> _ <span class="op">=</span> <span class="ident">server</span>.<span class="ident">tcp_listen</span>(<span class="number">1</span>).<span class="ident">unwrap</span>();

<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">client</span>.<span class="ident">connect</span>().<span class="ident">is_ok</span>())</pre>
</div><h4 id='method.flush' class="method"><span id='flush.v' class='invisible'><code>pub fn <a href='#method.flush' class='fnname'>flush</a>(&amp;self) -&gt; <a class="type" href="../libmodbus_rs/errors/type.Result.html" title="type libmodbus_rs::errors::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">()</a>&gt;</code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/libmodbus_rs/modbus.rs.html#174-182' title='goto source code'>[src]</a></span></h4>
<div class='docblock'><p><code>flush</code> - flush non-transmitted data</p>

<p>The <a href="#method.flush"><code>flush()</code></a> function shall discard data received but not read to the socket or file
descriptor associated to the context ctx.</p>

<h1 id='return-value-1' class='section-header'><a href='#return-value-1'>Return value</a></h1>
<p>The function return an OK Result if successful. Otherwise it contains an Error.</p>

<h1 id='examples-1' class='section-header'><a href='#examples-1'>Examples</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">libmodbus_rs</span>::{<span class="ident">Modbus</span>, <span class="ident">ModbusTCP</span>};
<span class="kw">let</span> <span class="ident">modbus</span> <span class="op">=</span> <span class="ident">Modbus</span>::<span class="ident">new_tcp</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">1502</span>).<span class="ident">unwrap</span>();

<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">modbus</span>.<span class="ident">flush</span>().<span class="ident">is_ok</span>());</pre>
</div><h4 id='method.set_slave' class="method"><span id='set_slave.v' class='invisible'><code>pub fn <a href='#method.set_slave' class='fnname'>set_slave</a>(&amp;mut self, slave: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>) -&gt; <a class="type" href="../libmodbus_rs/errors/type.Result.html" title="type libmodbus_rs::errors::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">()</a>&gt;</code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/libmodbus_rs/modbus.rs.html#220-228' title='goto source code'>[src]</a></span></h4>
<div class='docblock'><p><code>set_slave</code> - set slave number in the context</p>

<p>The <a href="#method.set_slave"><code>set_slave()</code></a> function shall set the slave number in the libmodbus context.
The behavior depends of network and the role of the device:</p>

<p>RTU
    Define the slave ID of the remote device to talk in master mode or set the internal slave ID in slave mode.
According to the protocol, a Modbus device must only accept message holding its slave number or the special
broadcast number.
TCP
    The slave number is only required in TCP if the message must reach a device on a serial network.
    Some not compliant devices or software (such as modpoll) uses the slave ID as unit identifier,
    that’s incorrect (cf page 23 of Modbus Messaging Implementation Guide v1.0b) but without the slave value,
    the faulty remote device or software drops the requests!
    The special value MODBUS_TCP_SLAVE (0xFF) can be used in TCP mode to restore the default value.
    The broadcast address is MODBUS_BROADCAST_ADDRESS.
    This special value must be use when you want all Modbus devices of the network receive the request.</p>

<h1 id='return-value-2' class='section-header'><a href='#return-value-2'>Return value</a></h1>
<p>The function return an OK Result if successful. Otherwise it contains an Error.</p>

<h1 id='parameters' class='section-header'><a href='#parameters'>Parameters</a></h1>
<ul>
<li><code>slave</code>   - new slave ID</li>
</ul>

<h1 id='examples-2' class='section-header'><a href='#examples-2'>Examples</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">libmodbus_rs</span>::{<span class="ident">Modbus</span>, <span class="ident">ModbusRTU</span>};

<span class="kw">const</span> <span class="ident">YOUR_DEVICE_ID</span>: <span class="ident">u8</span> <span class="op">=</span> <span class="number">1</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">modbus</span> <span class="op">=</span> <span class="ident">Modbus</span>::<span class="ident">new_rtu</span>(<span class="string">&quot;/dev/ttyUSB0&quot;</span>, <span class="number">115200</span>, <span class="string">&#39;N&#39;</span>, <span class="number">8</span>, <span class="number">1</span>).<span class="ident">unwrap</span>();

<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">modbus</span>.<span class="ident">set_slave</span>(<span class="ident">YOUR_DEVICE_ID</span>).<span class="ident">is_ok</span>());</pre>
</div><h4 id='method.set_debug' class="method"><span id='set_debug.v' class='invisible'><code>pub fn <a href='#method.set_debug' class='fnname'>set_debug</a>(&amp;mut self, flag: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>) -&gt; <a class="type" href="../libmodbus_rs/errors/type.Result.html" title="type libmodbus_rs::errors::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">()</a>&gt;</code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/libmodbus_rs/modbus.rs.html#261-269' title='goto source code'>[src]</a></span></h4>
<div class='docblock'><p><code>set_debug</code> - set debug flag of the context</p>

<p>The <a href="#method.set_debug"><code>set_debug()</code></a> function shall set the debug flag of the modbus_t context by using the
argument flag.
By default, the boolean flag is set to FALSE. When the flag value is set to TRUE, many verbose messages are
displayed on stdout and stderr.
For example, this flag is useful to display the bytes of the Modbus messages.</p>

<pre><code class="language-bash">[00][14][00][00][00][06][12][03][00][6B][00][03]
Waiting for a confirmation…
&lt;00&gt;&lt;14&gt;&lt;00&gt;&lt;00&gt;&lt;00&gt;&lt;09&gt;&lt;12&gt;&lt;03&gt;&lt;06&gt;&lt;02&gt;&lt;2B&gt;&lt;00&gt;&lt;00&gt;&lt;00&gt;&lt;00&gt;
</code></pre>

<h1 id='return-value-3' class='section-header'><a href='#return-value-3'>Return value</a></h1>
<p>The function return an OK Result if successful. Otherwise it contains an Error.</p>

<h1 id='parameters-1' class='section-header'><a href='#parameters-1'>Parameters</a></h1>
<ul>
<li><code>flag</code>    - <code>true</code> of <code>false</code>, enables or disables debug mode</li>
</ul>

<h1 id='examples-3' class='section-header'><a href='#examples-3'>Examples</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">libmodbus_rs</span>::{<span class="ident">Modbus</span>, <span class="ident">ModbusTCP</span>};

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">modbus</span> <span class="op">=</span> <span class="ident">Modbus</span>::<span class="ident">new_tcp</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">1502</span>).<span class="ident">unwrap</span>();

<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">modbus</span>.<span class="ident">set_debug</span>(<span class="bool-val">true</span>).<span class="ident">is_ok</span>());</pre>
</div><h4 id='method.get_byte_timeout' class="method"><span id='get_byte_timeout.v' class='invisible'><code>pub fn <a href='#method.get_byte_timeout' class='fnname'>get_byte_timeout</a>(&amp;self) -&gt; <a class="type" href="../libmodbus_rs/errors/type.Result.html" title="type libmodbus_rs::errors::Result">Result</a>&lt;<a class="struct" href="../libmodbus_rs/struct.Timeout.html" title="struct libmodbus_rs::Timeout">Timeout</a>&gt;</code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/libmodbus_rs/modbus.rs.html#290-299' title='goto source code'>[src]</a></span></h4>
<div class='docblock'><p><code>get_byte_timeout</code> - get timeout between bytes</p>

<p><a href="#method.get_byte_timeout"><code>get_byte_timeout()</code></a> function returns a
<a href="struct.Timeout.html"><code>Timeout</code></a> with the timeout interval between
two consecutive bytes of the same message.</p>

<h1 id='return-value-4' class='section-header'><a href='#return-value-4'>Return value</a></h1>
<p>The function return a Result containing a <a href="struct.Timeout.html"><code>Timeout</code></a> if successful.
Otherwise it contains an Error.</p>

<h1 id='examples-4' class='section-header'><a href='#examples-4'>Examples</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">libmodbus_rs</span>::{<span class="ident">Modbus</span>, <span class="ident">ModbusTCP</span>, <span class="ident">Timeout</span>};
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">modbus</span> <span class="op">=</span> <span class="ident">Modbus</span>::<span class="ident">new_tcp</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">1502</span>).<span class="ident">unwrap</span>();

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">modbus</span>.<span class="ident">get_byte_timeout</span>().<span class="ident">unwrap</span>(), <span class="ident">Timeout</span> { <span class="ident">sec</span>: <span class="number">0</span>, <span class="ident">usec</span>: <span class="number">500000</span> });</pre>
</div><h4 id='method.set_byte_timeout' class="method"><span id='set_byte_timeout.v' class='invisible'><code>pub fn <a href='#method.set_byte_timeout' class='fnname'>set_byte_timeout</a>(&amp;mut self, timeout: <a class="struct" href="../libmodbus_rs/struct.Timeout.html" title="struct libmodbus_rs::Timeout">Timeout</a>) -&gt; <a class="type" href="../libmodbus_rs/errors/type.Result.html" title="type libmodbus_rs::errors::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">()</a>&gt;</code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/libmodbus_rs/modbus.rs.html#333-341' title='goto source code'>[src]</a></span></h4>
<div class='docblock'><p><code>set_byte_timeout</code> - set timeout between bytes</p>

<p>The <a href="#method.set_byte_timeout"><code>set_byte_timeout()</code></a> function shall set the timeout interval between two
consecutive bytes of the same message.
The timeout is an upper bound on the amount of time elapsed before select() returns, if the time elapsed is
longer than the defined timeout,
an ETIMEDOUT error will be raised by the function waiting for a response.</p>

<p>The value of <strong>usec</strong> argument must be in the range 0 to 999999.</p>

<p>If both <strong>sec</strong> and <strong>usec</strong> are zero, this timeout will not be used at all. In this case,
<a href="#method.set_byte_timeout"><code>set_byte_timeout()</code></a>
governs the entire handling of the response, the full confirmation response must be received before expiration
of the response timeout.
When a byte timeout is set, the response timeout is only used to wait for until the first byte of the response.</p>

<h1 id='return-value-5' class='section-header'><a href='#return-value-5'>Return value</a></h1>
<p>The function return an OK Result if successful. Otherwise it contains an Error.</p>

<h1 id='parameters-2' class='section-header'><a href='#parameters-2'>Parameters</a></h1>
<ul>
<li><code>timeout</code>  - Timeout struct with <code>sec</code> and <code>usec</code></li>
</ul>

<h1 id='examples-5' class='section-header'><a href='#examples-5'>Examples</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">libmodbus_rs</span>::{<span class="ident">Modbus</span>, <span class="ident">ModbusTCP</span>, <span class="ident">Timeout</span>};
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">modbus</span> <span class="op">=</span> <span class="ident">Modbus</span>::<span class="ident">new_tcp</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">1502</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">timeout</span> <span class="op">=</span> <span class="ident">Timeout</span> { <span class="ident">sec</span>: <span class="number">1</span>, <span class="ident">usec</span>: <span class="number">500000</span> };
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">modbus</span>.<span class="ident">set_byte_timeout</span>(<span class="ident">timeout</span>).<span class="ident">is_ok</span>());</pre>
</div><h4 id='method.get_response_timeout' class="method"><span id='get_response_timeout.v' class='invisible'><code>pub fn <a href='#method.get_response_timeout' class='fnname'>get_response_timeout</a>(&amp;self) -&gt; <a class="type" href="../libmodbus_rs/errors/type.Result.html" title="type libmodbus_rs::errors::Result">Result</a>&lt;<a class="struct" href="../libmodbus_rs/struct.Timeout.html" title="struct libmodbus_rs::Timeout">Timeout</a>&gt;</code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/libmodbus_rs/modbus.rs.html#362-371' title='goto source code'>[src]</a></span></h4>
<div class='docblock'><p><code>get_response_timeout</code> - get timeout for response</p>

<p>The <a href="#method.get_response_timeout"><code>get_response_timeout()</code></a> function shall return the timeout interval used to
wait for a response
in the <strong>sec</strong> and <strong>usec</strong> arguments.</p>

<h1 id='return-value-6' class='section-header'><a href='#return-value-6'>Return value</a></h1>
<p>The function return a Result containing a <a href="struct.Timeout.html"><code>Timeout</code></a> if successful.
Otherwise it contains an Error.</p>

<h1 id='examples-6' class='section-header'><a href='#examples-6'>Examples</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">libmodbus_rs</span>::{<span class="ident">Modbus</span>, <span class="ident">ModbusTCP</span>, <span class="ident">Timeout</span>};
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">modbus</span> <span class="op">=</span> <span class="ident">Modbus</span>::<span class="ident">new_tcp</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">1502</span>).<span class="ident">unwrap</span>();

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">modbus</span>.<span class="ident">get_response_timeout</span>().<span class="ident">unwrap</span>(), <span class="ident">Timeout</span> { <span class="ident">sec</span>: <span class="number">0</span>, <span class="ident">usec</span>: <span class="number">500000</span> });</pre>
</div><h4 id='method.set_response_timeout' class="method"><span id='set_response_timeout.v' class='invisible'><code>pub fn <a href='#method.set_response_timeout' class='fnname'>set_response_timeout</a>(&amp;mut self, timeout: <a class="struct" href="../libmodbus_rs/struct.Timeout.html" title="struct libmodbus_rs::Timeout">Timeout</a>) -&gt; <a class="type" href="../libmodbus_rs/errors/type.Result.html" title="type libmodbus_rs::errors::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">()</a>&gt;</code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/libmodbus_rs/modbus.rs.html#404-412' title='goto source code'>[src]</a></span></h4>
<div class='docblock'><p><code>set_response_timeout</code> - set timeout for response</p>

<p>The <a href="#method.set_response_timeout"><code>set_response_timeout()</code></a> function shall set the timeout interval used to
wait for a response.
When a byte timeout is set, if elapsed time for the first byte of response is longer than the given timeout,
an ETIMEDOUT error will be raised by the function waiting for a response. When byte timeout is disabled,
the full confirmation response must be received before expiration of the response timeout.</p>

<p>If the <a href="struct.Timeout.html"><code>Timeout</code></a> members are both <strong>sec</strong> and <strong>usec</strong> are zero,
this timeout will not be used at all. In this case, <a href="#method.set_response_timeout"><code>set_response_timeout()</code></a>
governs the entire handling of the response, the full confirmation response must be received before expiration
of the response timeout.
When a byte timeout is set, the response timeout is only used to wait for until the first byte of the response.</p>

<h1 id='return-value-7' class='section-header'><a href='#return-value-7'>Return value</a></h1>
<p>The function return an OK Result if successful. Otherwise it contains an Error.</p>

<h1 id='parameters-3' class='section-header'><a href='#parameters-3'>Parameters</a></h1>
<ul>
<li><a href="struct.Timeout.html"><code>Timeout</code></a>  - Timeout</li>
</ul>

<h1 id='examples-7' class='section-header'><a href='#examples-7'>Examples</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">libmodbus_rs</span>::{<span class="ident">Modbus</span>, <span class="ident">ModbusTCP</span>, <span class="ident">Timeout</span>};
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">modbus</span> <span class="op">=</span> <span class="ident">Modbus</span>::<span class="ident">new_tcp</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">1502</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">timeout</span> <span class="op">=</span> <span class="ident">Timeout</span> { <span class="ident">sec</span>: <span class="number">1</span>, <span class="ident">usec</span>: <span class="number">500000</span> };
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">modbus</span>.<span class="ident">set_response_timeout</span>(<span class="ident">timeout</span>).<span class="ident">is_ok</span>());</pre>
</div><h4 id='method.set_error_recovery' class="method"><span id='set_error_recovery.v' class='invisible'><code>pub fn <a href='#method.set_error_recovery' class='fnname'>set_error_recovery</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self, <br>&nbsp;&nbsp;&nbsp;&nbsp;flags: <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;[</a><a class="enum" href="../libmodbus_rs/enum.ErrorRecoveryMode.html" title="enum libmodbus_rs::ErrorRecoveryMode">ErrorRecoveryMode</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;<br>) -&gt; <a class="type" href="../libmodbus_rs/errors/type.Result.html" title="type libmodbus_rs::errors::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">()</a>&gt;</code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/libmodbus_rs/modbus.rs.html#456-468' title='goto source code'>[src]</a></span></h4>
<div class='docblock'><p><code>set_error_recovery</code> - set the error recovery mode</p>

<p>The <a href="#method.set_error_recovery"><code>set_error_recovery()</code></a> function shall set the error recovery mode to apply
when the connection fails or the byte received is not expected.</p>

<p>By default there is no error recovery so the application is responsible for controlling the error values
returned by libmodbus functions and for handling them if necessary.</p>

<p>When <code>ErrorRecoveryMode::Link</code> is set, the library will attempt an reconnection after a delay defined by
response timeout (<a href="#method.set_response_timeout"><code>set_response_timeout()</code></a>) of the libmodbus context.
This mode will try an infinite close/connect loop until success on send call and will just try one time to
re-establish the connection on select/read calls (if the connection was down, the values to read are certainly
not available any more after reconnection, except for slave/server).
This mode will also run flush requests after a delay based on  the current response timeout in some situations
(eg. timeout of select call).
The reconnection attempt can hang for several seconds if the network to the remote target unit is down.</p>

<p>When <code>ErrorRecoveryMode::PROTOCOL</code> is set, a sleep and flush sequence will be used to clean up the ongoing
communication, this can occurs when the message length is invalid, the TID is wrong or the received function
code is not the expected one.
The response timeout delay will be used to sleep.</p>

<p>The modes are mask values and so they are complementary.</p>

<p>It’s not recommended to enable error recovery for slave/server.</p>

<h1 id='return-value-8' class='section-header'><a href='#return-value-8'>Return value</a></h1>
<p>The function return an OK Result if successful. Otherwise it contains an Error.</p>

<h1 id='parameters-4' class='section-header'><a href='#parameters-4'>Parameters</a></h1>
<ul>
<li><a href="struct.ErrorRecoveryMode.html"><code>ErrorRecoveryMode</code></a>  - Timeout</li>
</ul>

<h1 id='examples-8' class='section-header'><a href='#examples-8'>Examples</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">libmodbus_rs</span>::{<span class="ident">Modbus</span>, <span class="ident">ModbusTCP</span>, <span class="ident">ErrorRecoveryMode</span>};
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">modbus</span> <span class="op">=</span> <span class="ident">Modbus</span>::<span class="ident">new_tcp</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">1502</span>).<span class="ident">unwrap</span>();

<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">modbus</span>.<span class="ident">set_error_recovery</span>(<span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span>[<span class="ident">ErrorRecoveryMode</span>::<span class="ident">Link</span>, <span class="ident">ErrorRecoveryMode</span>::<span class="ident">Protocol</span>])).<span class="ident">is_ok</span>());</pre>
</div><h4 id='method.set_socket' class="method"><span id='set_socket.v' class='invisible'><code>pub fn <a href='#method.set_socket' class='fnname'>set_socket</a>(&amp;mut self, socket: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i32.html">i32</a>) -&gt; <a class="type" href="../libmodbus_rs/errors/type.Result.html" title="type libmodbus_rs::errors::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">()</a>&gt;</code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/libmodbus_rs/modbus.rs.html#489-498' title='goto source code'>[src]</a></span></h4>
<div class='docblock'><p><code>set_socket</code> - set socket of the context</p>

<p>The <a href="#method.set_socket"><code>set_socket()</code></a> function shall set the socket or file descriptor in the libmodbus
context.
This function is useful for managing multiple client connections to the same server.</p>

<h1 id='return-values' class='section-header'><a href='#return-values'>Return values</a></h1>
<p>The function return an OK Result if successful. Otherwise it contains an Error.</p>

<h1 id='examples-9' class='section-header'><a href='#examples-9'>Examples</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">libmodbus_rs</span>::{<span class="ident">Modbus</span>, <span class="ident">ModbusTCP</span>};
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">modbus</span> <span class="op">=</span> <span class="ident">Modbus</span>::<span class="ident">new_tcp</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">1502</span>).<span class="ident">unwrap</span>();

<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">modbus</span>.<span class="ident">set_socket</span>(<span class="number">1337</span>).<span class="ident">is_ok</span>());</pre>
</div><h4 id='method.get_socket' class="method"><span id='get_socket.v' class='invisible'><code>pub fn <a href='#method.get_socket' class='fnname'>get_socket</a>(&amp;self) -&gt; <a class="type" href="../libmodbus_rs/errors/type.Result.html" title="type libmodbus_rs::errors::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i32.html">i32</a>&gt;</code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/libmodbus_rs/modbus.rs.html#518-525' title='goto source code'>[src]</a></span></h4>
<div class='docblock'><p><code>get_socket</code> - set socket of the context</p>

<p>The <a href="#method.get_socket"><code>get_socket()</code></a> function shall return the current socket or file descriptor of the
libmodbus context.</p>

<h1 id='return-value-9' class='section-header'><a href='#return-value-9'>Return value</a></h1>
<p>The function returns a Result containing the current socket or file descriptor of the context if successful.
Otherwise it contains an Error.</p>

<h1 id='examples-10' class='section-header'><a href='#examples-10'>Examples</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">libmodbus_rs</span>::{<span class="ident">Modbus</span>, <span class="ident">ModbusTCP</span>};
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">modbus</span> <span class="op">=</span> <span class="ident">Modbus</span>::<span class="ident">new_tcp</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">1502</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> _ <span class="op">=</span> <span class="ident">modbus</span>.<span class="ident">set_socket</span>(<span class="number">1337</span>).<span class="ident">unwrap</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">modbus</span>.<span class="ident">get_socket</span>().<span class="ident">unwrap</span>(), <span class="number">1337</span>);</pre>
</div><h4 id='method.get_header_length' class="method"><span id='get_header_length.v' class='invisible'><code>pub fn <a href='#method.get_header_length' class='fnname'>get_header_length</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i32.html">i32</a></code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/libmodbus_rs/modbus.rs.html#544-546' title='goto source code'>[src]</a></span></h4>
<div class='docblock'><p><code>get_header_length</code> - retrieve the current header length</p>

<p>The <a href="#method.get_header_length"><code>get_header_length()</code></a> function shall retrieve the current header length from
the backend.
This function is convenient to manipulate a message and so its limited to low-level operations.</p>

<h1 id='return-values-1' class='section-header'><a href='#return-values-1'>Return values</a></h1>
<p>The header length as integer value.</p>

<h1 id='examples-11' class='section-header'><a href='#examples-11'>Examples</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">libmodbus_rs</span>::{<span class="ident">Modbus</span>, <span class="ident">ModbusTCP</span>};
<span class="kw">let</span> <span class="ident">modbus</span> <span class="op">=</span> <span class="ident">Modbus</span>::<span class="ident">new_tcp</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">1502</span>).<span class="ident">unwrap</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">modbus</span>.<span class="ident">get_header_length</span>(), <span class="number">7</span>);</pre>
</div><h4 id='method.reply_exception' class="method"><span id='reply_exception.v' class='invisible'><code>pub fn <a href='#method.reply_exception' class='fnname'>reply_exception</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;request: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;exception_code: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a><br>) -&gt; <a class="type" href="../libmodbus_rs/errors/type.Result.html" title="type libmodbus_rs::errors::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i32.html">i32</a>&gt;</code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/libmodbus_rs/modbus.rs.html#587-594' title='goto source code'>[src]</a></span></h4>
<div class='docblock'><p><code>reply_exception</code> - send an exception reponse</p>

<p>The modbus_reply_exception() function shall send an exception response based on the exception_code in argument.</p>

<p>The libmodbus provides the following exception codes:</p>

<ul>
<li>Modbus::Exception::IllegalFunction  (1)</li>
<li>Modbus::Exception::IllegalDataAddress  (2)</li>
<li>Modbus::Exception::IllegalDataValue  (3)</li>
<li>Modbus::Exception::SlaveOrServerFailure  (4)</li>
<li>Modbus::Exception::Acknowledge  (5)</li>
<li>Modbus::Exception::SlaveDeviceBusy  (6)</li>
<li>Modbus::Exception::NegativeAcknowledge  (7)</li>
<li>Modbus::Exception::MemoryParity  (8)</li>
<li>Modbus::Exception::NotDefined  (9)</li>
<li>Modbus::Exception::GatewayPath (10)</li>
<li>Modbus::Exception::GatewayTarget (11)</li>
</ul>

<p>The initial request <code>request</code> is required to build a valid response.</p>

<h1 id='return-value-10' class='section-header'><a href='#return-value-10'>Return value</a></h1>
<p>The function returns the length of the response sent if successful, or an Error.</p>

<h1 id='parameters-5' class='section-header'><a href='#parameters-5'>Parameters</a></h1>
<ul>
<li><code>request</code>         - initial request, required to build a valid response</li>
<li><code>exception_code</code>  - Exception Code</li>
</ul>

<h1 id='examples-12' class='section-header'><a href='#examples-12'>Examples</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">libmodbus_rs</span>::{<span class="ident">Modbus</span>, <span class="ident">ModbusClient</span>, <span class="ident">ModbusTCP</span>};
<span class="kw">let</span> <span class="ident">modbus</span> <span class="op">=</span> <span class="ident">Modbus</span>::<span class="ident">new_tcp</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">1502</span>).<span class="ident">unwrap</span>();
<span class="kw">use</span> <span class="ident">libmodbus_rs</span>::<span class="ident">Exception</span>;

<span class="kw">let</span> <span class="ident">request</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="number">0x01</span>];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">modbus</span>.<span class="ident">reply_exception</span>(<span class="kw-2">&amp;</span><span class="ident">request</span>, <span class="ident">Exception</span>::<span class="ident">Acknowledge</span> <span class="kw">as</span> <span class="ident">u32</span>).<span class="ident">unwrap</span>(), <span class="number">9</span>);</pre>
</div><h4 id='method.close' class="method"><span id='close.v' class='invisible'><code>pub fn <a href='#method.close' class='fnname'>close</a>(&amp;self)</code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/libmodbus_rs/modbus.rs.html#611-615' title='goto source code'>[src]</a></span></h4>
<div class='docblock'><p><code>close</code> - close a Modbus connection</p>

<p>The <a href="#method.close"><code>close()</code></a> function shall close the connection established with the backend set in the
context.</p>

<p><strong>It should not nessesary to call these function. Because rusts drop trait handles that for you!</strong></p>

<h1 id='examples-13' class='section-header'><a href='#examples-13'>Examples</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">libmodbus_rs</span>::{<span class="ident">Modbus</span>, <span class="ident">ModbusTCP</span>};
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">modbus</span> <span class="op">=</span> <span class="ident">Modbus</span>::<span class="ident">new_tcp</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">1502</span>).<span class="ident">unwrap</span>();
<span class="ident">modbus</span>.<span class="ident">close</span>();</pre>
</div><h4 id='method.free' class="method"><span id='free.v' class='invisible'><code>pub fn <a href='#method.free' class='fnname'>free</a>(&amp;mut self)</code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/libmodbus_rs/modbus.rs.html#630-634' title='goto source code'>[src]</a></span></h4>
<div class='docblock'><p><code>free</code> - free a libmodbus context</p>

<p>The <a href="#method.free"><code>free()</code></a> function shall free an allocated modbus_t structure.</p>

<p><strong>It should not nessesary to call these function. Because rusts drop trait handles that for you!</strong></p>

<h1 id='examples-14' class='section-header'><a href='#examples-14'>Examples</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">libmodbus_rs</span>::{<span class="ident">Modbus</span>, <span class="ident">ModbusTCP</span>};
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">modbus</span> <span class="op">=</span> <span class="ident">Modbus</span>::<span class="ident">new_tcp</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">1502</span>).<span class="ident">unwrap</span>();
<span class="ident">modbus</span>.<span class="ident">free</span>();</pre>
</div></div>
            <h2 id='implementations' class='small-section-header'>
              Trait Implementations<a href='#implementations' class='anchor'></a>
            </h2>
        <h3 id='impl-ModbusClient' class='impl'><span class='in-band'><code>impl <a class="trait" href="../libmodbus_rs/trait.ModbusClient.html" title="trait libmodbus_rs::ModbusClient">ModbusClient</a> for <a class="struct" href="../libmodbus_rs/struct.Modbus.html" title="struct libmodbus_rs::Modbus">Modbus</a></code><a href='#impl-ModbusClient' class='anchor'></a></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/libmodbus_rs/modbus_client.rs.html#48-538' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.read_bits' class="method"><span id='read_bits.v' class='invisible'><code>fn <a href='../libmodbus_rs/trait.ModbusClient.html#tymethod.read_bits' class='fnname'>read_bits</a>(&amp;self, address: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i32.html">i32</a>, num: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i32.html">i32</a>, dest: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;mut [</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>) -&gt; <a class="type" href="../libmodbus_rs/errors/type.Result.html" title="type libmodbus_rs::errors::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i32.html">i32</a>&gt;</code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/libmodbus_rs/modbus_client.rs.html#76-87' title='goto source code'>[src]</a></span></h4>
<div class='docblock'><p><code>read_bits</code> - read many bits</p>

<p>The <a href="#method.read_bits"><code>read_bits()</code></a> function shall read the status of the <code>num</code> bits (coils) to the
<code>address</code> of the remote device. The result of reading is stored in <code>dest</code> slice as unsigned bytes (8 bits) set
to TRUE or FALSE.</p>

<p>The function uses the <strong>Modbus function code 0x01</strong> (read coil status).</p>

<h1 id='return-value-11' class='section-header'><a href='#return-value-11'>Return value</a></h1>
<p>The function returns a <code>Result</code> containing the number of read bits if successful. Otherwise it returns an Error.</p>

<h1 id='parameters-6' class='section-header'><a href='#parameters-6'>Parameters</a></h1>
<ul>
<li><code>address</code> - address of the remote device</li>
<li><code>num</code>     - number of coils to read</li>
<li><code>dest</code>    - the result of the reading is stored here</li>
</ul>

<h1 id='examples-15' class='section-header'><a href='#examples-15'>Examples</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">libmodbus_rs</span>::{<span class="ident">Modbus</span>, <span class="ident">ModbusClient</span>, <span class="ident">ModbusTCP</span>};
<span class="kw">let</span> <span class="ident">modbus</span> <span class="op">=</span> <span class="ident">Modbus</span>::<span class="ident">new_tcp</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">1502</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">dest</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="number">0u8</span>; <span class="number">100</span>];

<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">modbus</span>.<span class="ident">read_bits</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">dest</span>).<span class="ident">is_ok</span>());</pre>
</div><h4 id='method.read_input_bits' class="method"><span id='read_input_bits.v' class='invisible'><code>fn <a href='../libmodbus_rs/trait.ModbusClient.html#tymethod.read_input_bits' class='fnname'>read_input_bits</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;address: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i32.html">i32</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;num: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i32.html">i32</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;dest: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;mut [</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a><br>) -&gt; <a class="type" href="../libmodbus_rs/errors/type.Result.html" title="type libmodbus_rs::errors::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i32.html">i32</a>&gt;</code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/libmodbus_rs/modbus_client.rs.html#116-127' title='goto source code'>[src]</a></span></h4>
<div class='docblock'><p><code>read_input_bits</code> - read many input bits</p>

<p>The <a href="#method.read_input_bits"><code>read_input_bits()</code></a> function shall read the content of the <code>num</code> input bits to
the <code>address</code> of the remote device. The result of reading is stored in <code>dest</code> slice as unsigned bytes (8 bits)
set to TRUE or FALSE.</p>

<p>The function uses the <strong>Modbus function code 0x02</strong> (read input status).</p>

<h1 id='return-value-12' class='section-header'><a href='#return-value-12'>Return value</a></h1>
<p>The function returns a <code>Result</code> containing the number of read bits if successful. Otherwise it returns an Error.</p>

<h1 id='parameters-7' class='section-header'><a href='#parameters-7'>Parameters</a></h1>
<ul>
<li><code>address</code> - address of the remote device</li>
<li><code>num</code>     - number of input bits to read</li>
<li><code>dest</code>    - the result of the reading is stored here</li>
</ul>

<h1 id='examples-16' class='section-header'><a href='#examples-16'>Examples</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">libmodbus_rs</span>::{<span class="ident">Modbus</span>, <span class="ident">ModbusClient</span>, <span class="ident">ModbusTCP</span>};
<span class="kw">let</span> <span class="ident">modbus</span> <span class="op">=</span> <span class="ident">Modbus</span>::<span class="ident">new_tcp</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">1502</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">dest</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="number">0u8</span>; <span class="number">100</span>];

<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">modbus</span>.<span class="ident">read_input_bits</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">dest</span>).<span class="ident">is_ok</span>());</pre>
</div><h4 id='method.read_registers' class="method"><span id='read_registers.v' class='invisible'><code>fn <a href='../libmodbus_rs/trait.ModbusClient.html#tymethod.read_registers' class='fnname'>read_registers</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;address: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i32.html">i32</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;num: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i32.html">i32</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;dest: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;mut [</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u16.html">u16</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a><br>) -&gt; <a class="type" href="../libmodbus_rs/errors/type.Result.html" title="type libmodbus_rs::errors::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i32.html">i32</a>&gt;</code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/libmodbus_rs/modbus_client.rs.html#155-166' title='goto source code'>[src]</a></span></h4>
<div class='docblock'><p><code>read_registers</code> - read many registers</p>

<p>The <a href="#method.read_registers"><code>read_registers()</code></a> function shall read the content of the <code>num</code> holding registers
to the <code>address</code> of the remote device. The result of reading is stored in <code>dest</code> slice as u16 word values.</p>

<p>The function uses the <strong>Modbus function code 0x03</strong> (read holding registers).</p>

<h1 id='return-value-13' class='section-header'><a href='#return-value-13'>Return value</a></h1>
<p>The function returns a <code>Result</code> containing the number of read bits if successful. Otherwise it returns an Error.</p>

<h1 id='parameters-8' class='section-header'><a href='#parameters-8'>Parameters</a></h1>
<ul>
<li><code>address</code> - address of the remote device</li>
<li><code>num</code>     - number of holding registers to read</li>
<li><code>dest</code>    - the result of the reading is stored here</li>
</ul>

<h1 id='examples-17' class='section-header'><a href='#examples-17'>Examples</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">libmodbus_rs</span>::{<span class="ident">Modbus</span>, <span class="ident">ModbusClient</span>, <span class="ident">ModbusTCP</span>};
<span class="kw">let</span> <span class="ident">modbus</span> <span class="op">=</span> <span class="ident">Modbus</span>::<span class="ident">new_tcp</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">1502</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">dest</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="number">0u16</span>; <span class="number">100</span>];

<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">modbus</span>.<span class="ident">read_registers</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">dest</span>).<span class="ident">is_ok</span>());</pre>
</div><h4 id='method.read_input_registers' class="method"><span id='read_input_registers.v' class='invisible'><code>fn <a href='../libmodbus_rs/trait.ModbusClient.html#tymethod.read_input_registers' class='fnname'>read_input_registers</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;address: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i32.html">i32</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;num: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i32.html">i32</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;dest: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;mut [</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u16.html">u16</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a><br>) -&gt; <a class="type" href="../libmodbus_rs/errors/type.Result.html" title="type libmodbus_rs::errors::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i32.html">i32</a>&gt;</code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/libmodbus_rs/modbus_client.rs.html#196-207' title='goto source code'>[src]</a></span></h4>
<div class='docblock'><p><code>read_input_registers</code> -  read many input registers</p>

<p>The <a href="#method.read_input_registers"><code>read_input_registers()</code></a> function shall read the content of the <code>num</code>
holding registers to the <code>address</code> of the remote device. The result of reading is stored in <code>dest</code> slice as u16
word values.</p>

<p>The function uses the <strong>Modbus function code 0x04</strong> (read input registers). The holding registers and input
registers have different historical meaning, but nowadays it’s more common to use holding registers only.</p>

<h1 id='return-value-14' class='section-header'><a href='#return-value-14'>Return value</a></h1>
<p>The function returns a <code>Result</code> containing the number of read bits if successful. Otherwise it returns an Error.</p>

<h1 id='parameters-9' class='section-header'><a href='#parameters-9'>Parameters</a></h1>
<ul>
<li><code>address</code> - address of the remote device</li>
<li><code>num</code>     - number of input registers to read</li>
<li><code>dest</code>    - the result of the reading is stored here</li>
</ul>

<h1 id='examples-18' class='section-header'><a href='#examples-18'>Examples</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">libmodbus_rs</span>::{<span class="ident">Modbus</span>, <span class="ident">ModbusClient</span>, <span class="ident">ModbusTCP</span>};
<span class="kw">let</span> <span class="ident">modbus</span> <span class="op">=</span> <span class="ident">Modbus</span>::<span class="ident">new_tcp</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">1502</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">dest</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="number">0u16</span>; <span class="number">100</span>];

<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">modbus</span>.<span class="ident">read_input_registers</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">dest</span>).<span class="ident">is_ok</span>());</pre>
</div><h4 id='method.report_slave_id' class="method"><span id='report_slave_id.v' class='invisible'><code>fn <a href='../libmodbus_rs/trait.ModbusClient.html#tymethod.report_slave_id' class='fnname'>report_slave_id</a>(&amp;self, max_dest: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, dest: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;mut [</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>) -&gt; <a class="type" href="../libmodbus_rs/errors/type.Result.html" title="type libmodbus_rs::errors::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i32.html">i32</a>&gt;</code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/libmodbus_rs/modbus_client.rs.html#241-252' title='goto source code'>[src]</a></span></h4>
<div class='docblock'><p><code>report_slave_id</code> - returns a description of the controller</p>

<p>The <a href="#method.report_slave_id"><code>report_slave_id()</code></a> function shall send a request to the controller to obtain a
description of the controller. The response stored in <code>dest</code> contains:
    * the slave ID, this unique ID is in reality not unique at all so it&#39;s not possible to depend on it to know
how the information are packed in the response.
    * the run indicator status (0x00 = OFF, 0xFF = ON)
    * additional data specific to each controller. For example, libmodbus returns the version of the library as
a string.</p>

<h1 id='return-value-15' class='section-header'><a href='#return-value-15'>Return value</a></h1>
<p>The function returns a <code>Result</code> containing the number of read bits if successful. If the output was truncated
due the <code>max_dest</code> limit then the return value is the number of bytes which would have been written to <code>dest</code>.
Thus, a return value greater than the <code>max_dest</code> means that the resonse data was truncated.
Otherwise the Result contains an Error.</p>

<h1 id='parameters-10' class='section-header'><a href='#parameters-10'>Parameters</a></h1>
<ul>
<li><code>max_dest</code>    - limit, write <code>max_dest</code> bytes from the response to <code>dest</code></li>
<li><code>dest</code>    - the result of the reading is stored here</li>
</ul>

<h1 id='examples-19' class='section-header'><a href='#examples-19'>Examples</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">libmodbus_rs</span>::{<span class="ident">Modbus</span>, <span class="ident">ModbusClient</span>, <span class="ident">ModbusTCP</span>};
<span class="kw">let</span> <span class="ident">modbus</span> <span class="op">=</span> <span class="ident">Modbus</span>::<span class="ident">new_tcp</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">1502</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bytes</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="number">0u8</span>; <span class="ident">Modbus</span>::<span class="ident">MAX_PDU_LENGTH</span>];

<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">modbus</span>.<span class="ident">report_slave_id</span>(<span class="ident">Modbus</span>::<span class="ident">MAX_PDU_LENGTH</span>, <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">bytes</span>).<span class="ident">is_ok</span>());
<span class="comment">// assert_eq!(bytes, vec![180, 255, 76, 77, 66, 51, 46, 49, 46, 52]));</span></pre>
</div><h4 id='method.write_bit' class="method"><span id='write_bit.v' class='invisible'><code>fn <a href='../libmodbus_rs/trait.ModbusClient.html#tymethod.write_bit' class='fnname'>write_bit</a>(&amp;self, address: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i32.html">i32</a>, status: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>) -&gt; <a class="type" href="../libmodbus_rs/errors/type.Result.html" title="type libmodbus_rs::errors::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">()</a>&gt;</code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/libmodbus_rs/modbus_client.rs.html#279-287' title='goto source code'>[src]</a></span></h4>
<div class='docblock'><p><code>write_bit</code> - write a single bit</p>

<p>The <a href="#method.write_bit"><code>write_bit()</code></a> function shall write the <code>status</code> at the <code>address</code> of the remote device.
The value must be set to <code>true</code> of <code>false</code>.</p>

<p>The function uses the Modbus function code 0x05 (force single coil).</p>

<h1 id='return-value-16' class='section-header'><a href='#return-value-16'>Return value</a></h1>
<p>The function return an OK Result, containing a one, if successful. Otherwise it contains an Error.</p>

<h1 id='parameters-11' class='section-header'><a href='#parameters-11'>Parameters</a></h1>
<ul>
<li><code>address</code> - address of the remote device</li>
<li><code>status</code> - status that should write at the address <code>addr</code></li>
</ul>

<h1 id='examples-20' class='section-header'><a href='#examples-20'>Examples</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">libmodbus_rs</span>::{<span class="ident">Modbus</span>, <span class="ident">ModbusClient</span>, <span class="ident">ModbusTCP</span>};
<span class="kw">let</span> <span class="ident">modbus</span> <span class="op">=</span> <span class="ident">Modbus</span>::<span class="ident">new_tcp</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">1502</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">address</span> <span class="op">=</span> <span class="number">1</span>;

<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">modbus</span>.<span class="ident">write_bit</span>(<span class="ident">address</span>, <span class="bool-val">true</span>).<span class="ident">is_ok</span>());</pre>
</div><h4 id='method.write_register' class="method"><span id='write_register.v' class='invisible'><code>fn <a href='../libmodbus_rs/trait.ModbusClient.html#tymethod.write_register' class='fnname'>write_register</a>(&amp;self, address: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i32.html">i32</a>, value: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i32.html">i32</a>) -&gt; <a class="type" href="../libmodbus_rs/errors/type.Result.html" title="type libmodbus_rs::errors::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">()</a>&gt;</code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/libmodbus_rs/modbus_client.rs.html#315-323' title='goto source code'>[src]</a></span></h4>
<div class='docblock'><p><code>write_register</code> - write a single register</p>

<p>The <a href="#method.write_register"><code>write_register()</code></a> function shall write the value of value holding registers at
the address addr of the remote device.</p>

<p>The function uses the Modbus function code 0x06 (preset single register).</p>

<h1 id='return-value-17' class='section-header'><a href='#return-value-17'>Return value</a></h1>
<p>The function return an OK Result, containing a one, if successful. Otherwise it contains an Error.</p>

<h1 id='parameters-12' class='section-header'><a href='#parameters-12'>Parameters</a></h1>
<ul>
<li><code>address</code> - address of the remote device</li>
<li><code>value</code> - vec with the value of the holding register which shall be written</li>
</ul>

<h1 id='examples-21' class='section-header'><a href='#examples-21'>Examples</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">libmodbus_rs</span>::{<span class="ident">Modbus</span>, <span class="ident">ModbusClient</span>, <span class="ident">ModbusTCP</span>};
<span class="kw">let</span> <span class="ident">modbus</span> <span class="op">=</span> <span class="ident">Modbus</span>::<span class="ident">new_tcp</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">1502</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">address</span> <span class="op">=</span> <span class="number">1</span>;
<span class="kw">let</span> <span class="ident">value</span> <span class="op">=</span> <span class="ident">i32</span>::<span class="ident">max_value</span>();

<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">modbus</span>.<span class="ident">write_register</span>(<span class="ident">address</span>, <span class="ident">value</span>).<span class="ident">is_ok</span>());</pre>
</div><h4 id='method.write_bits' class="method"><span id='write_bits.v' class='invisible'><code>fn <a href='../libmodbus_rs/trait.ModbusClient.html#tymethod.write_bits' class='fnname'>write_bits</a>(&amp;self, address: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i32.html">i32</a>, num: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i32.html">i32</a>, src: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>) -&gt; <a class="type" href="../libmodbus_rs/errors/type.Result.html" title="type libmodbus_rs::errors::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i32.html">i32</a>&gt;</code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/libmodbus_rs/modbus_client.rs.html#352-359' title='goto source code'>[src]</a></span></h4>
<div class='docblock'><p><code>write_bits</code> - write many bits</p>

<p>The <a href="#method.write_bits"><code>write_bits()</code></a> function shall write the status of the bits (coils) from <code>src</code> at the
<code>address</code> of the remote device. The <code>src</code> array must contains bytes set to TRUE or FALSE.</p>

<p>The function shall return the number of written bits if successful. Otherwise it contains an Error.</p>

<h1 id='return-value-18' class='section-header'><a href='#return-value-18'>Return value</a></h1>
<p>The function returns a Ok Result containing the number of written bits. Otherwise it contains an Error.</p>

<h1 id='parameters-13' class='section-header'><a href='#parameters-13'>Parameters</a></h1>
<ul>
<li><code>address</code> - address of the remote device</li>
<li><code>num</code>     - number or bits that should be writen at the address <code>address</code></li>
<li><code>src</code>     - vec of <code>0</code> and <code>1</code> (true and false) values</li>
</ul>

<h1 id='examples-22' class='section-header'><a href='#examples-22'>Examples</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">libmodbus_rs</span>::{<span class="ident">Modbus</span>, <span class="ident">ModbusClient</span>, <span class="ident">ModbusTCP</span>};
<span class="kw">let</span> <span class="ident">modbus</span> <span class="op">=</span> <span class="ident">Modbus</span>::<span class="ident">new_tcp</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">1502</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">address</span> <span class="op">=</span> <span class="number">1</span>;
<span class="kw">let</span> <span class="ident">tab_bytes</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="number">0u8</span>];

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">modbus</span>.<span class="ident">write_bits</span>(<span class="ident">address</span>, <span class="number">1</span>, <span class="kw-2">&amp;</span><span class="ident">tab_bytes</span>).<span class="ident">unwrap</span>(), <span class="number">1</span>);</pre>
</div><h4 id='method.write_registers' class="method"><span id='write_registers.v' class='invisible'><code>fn <a href='../libmodbus_rs/trait.ModbusClient.html#tymethod.write_registers' class='fnname'>write_registers</a>(&amp;self, address: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i32.html">i32</a>, num: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i32.html">i32</a>, src: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u16.html">u16</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>) -&gt; <a class="type" href="../libmodbus_rs/errors/type.Result.html" title="type libmodbus_rs::errors::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i32.html">i32</a>&gt;</code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/libmodbus_rs/modbus_client.rs.html#389-396' title='goto source code'>[src]</a></span></h4>
<div class='docblock'><p><code>write_registers</code> - write many registers</p>

<p>The <a href="#method.write_registers"><code>write_registers()</code></a> function shall write the content of the <code>num</code> holding
registers
from the array <code>src</code> at <code>address</code> of the remote device.</p>

<p>The function uses the Modbus function code 0x10 (preset multiple registers).</p>

<h1 id='return-value-19' class='section-header'><a href='#return-value-19'>Return value</a></h1>
<p>The function returns a Ok Result containing the number of written bytes. Otherwise it contains an Error.</p>

<h1 id='parameters-14' class='section-header'><a href='#parameters-14'>Parameters</a></h1>
<ul>
<li><code>address</code> - address of the remote device</li>
<li><code>num</code>     - number of holding registers that should write at the address <code>address</code></li>
<li><code>src</code>     - holding register</li>
</ul>

<h1 id='examples-23' class='section-header'><a href='#examples-23'>Examples</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">libmodbus_rs</span>::{<span class="ident">Modbus</span>, <span class="ident">ModbusClient</span>, <span class="ident">ModbusTCP</span>};
<span class="kw">let</span> <span class="ident">modbus</span> <span class="op">=</span> <span class="ident">Modbus</span>::<span class="ident">new_tcp</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">1502</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">address</span> <span class="op">=</span> <span class="number">1</span>;
<span class="kw">let</span> <span class="ident">tab_bytes</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="number">0u16</span>];

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">modbus</span>.<span class="ident">write_registers</span>(<span class="ident">address</span>, <span class="number">1</span>, <span class="kw-2">&amp;</span><span class="ident">tab_bytes</span>).<span class="ident">unwrap</span>(), <span class="number">1</span>);</pre>
</div><h4 id='method.write_and_read_registers' class="method"><span id='write_and_read_registers.v' class='invisible'><code>fn <a href='../libmodbus_rs/trait.ModbusClient.html#tymethod.write_and_read_registers' class='fnname'>write_and_read_registers</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;write_address: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i32.html">i32</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;write_num: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i32.html">i32</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;src: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u16.html">u16</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;read_address: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i32.html">i32</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;read_num: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i32.html">i32</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;dest: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;mut [</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u16.html">u16</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a><br>) -&gt; <a class="type" href="../libmodbus_rs/errors/type.Result.html" title="type libmodbus_rs::errors::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i32.html">i32</a>&gt;</code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/libmodbus_rs/modbus_client.rs.html#433-448' title='goto source code'>[src]</a></span></h4>
<div class='docblock'><p><code>write_and_read_registers</code> - write and read many registers in a single transaction</p>

<p>The <a href="#method.write_and_read_registers"><code>write_and_read_registers()</code></a> function shall write the content of the
write_nb holding registers from the array src to the address write_addr of the remote device then shall read
the content of the read_nb holding registers to the address read_addr of the remote device. The result of
reading is stored in dest array as word values (16 bits).</p>

<p>The function uses the Modbus function code 0x17 (write/read registers).</p>

<h1 id='return-value-20' class='section-header'><a href='#return-value-20'>Return value</a></h1>
<p>The function returns a Ok Result containing the number of read registers. Otherwise it contains an Error.</p>

<h1 id='parameters-15' class='section-header'><a href='#parameters-15'>Parameters</a></h1>
<ul>
<li><code>write_address</code>   - address of the remote device</li>
<li><code>write_num</code>       - number of holding registers</li>
<li><code>src</code>             - holding register</li>
<li><code>read_address</code>    - address of the remote device</li>
<li><code>read_num</code>        - number of holding registers</li>
<li><code>dest</code>            - holding register</li>
</ul>

<h1 id='examples-24' class='section-header'><a href='#examples-24'>Examples</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">libmodbus_rs</span>::{<span class="ident">Modbus</span>, <span class="ident">ModbusClient</span>, <span class="ident">ModbusTCP</span>};
<span class="kw">let</span> <span class="ident">modbus</span> <span class="op">=</span> <span class="ident">Modbus</span>::<span class="ident">new_tcp</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">1502</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">address</span> <span class="op">=</span> <span class="number">1</span>;
<span class="kw">let</span> <span class="ident">request_bytes</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="number">1u16</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">response_bytes</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="number">0u16</span>];

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">modbus</span>.<span class="ident">write_and_read_registers</span>(
                <span class="ident">address</span>, <span class="number">1</span>, <span class="kw-2">&amp;</span><span class="ident">request_bytes</span>,
                <span class="ident">address</span>, <span class="number">1</span>, <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">response_bytes</span>).<span class="ident">unwrap</span>(), <span class="number">1</span>);</pre>
</div><h4 id='method.send_raw_request' class="method"><span id='send_raw_request.v' class='invisible'><code>fn <a href='../libmodbus_rs/trait.ModbusClient.html#tymethod.send_raw_request' class='fnname'>send_raw_request</a>(&amp;self, raw_request: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;mut [</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>) -&gt; <a class="type" href="../libmodbus_rs/errors/type.Result.html" title="type libmodbus_rs::errors::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i32.html">i32</a>&gt;</code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/libmodbus_rs/modbus_client.rs.html#482-491' title='goto source code'>[src]</a></span></h4>
<div class='docblock'><p><code>send_raw_request</code> - send a raw request</p>

<p>The <a href="#method.send_raw_request"><code>send_raw_request()</code></a> function shall send a request via the socket of the
current modbus contest.
This function must be used for debugging purposes because you have to take care to make a valid request by hand.
The function only adds to the message, the header or CRC of the selected backend, so <code>raw_request</code> must start
and
contain at least a slave/unit identifier and a function code.
This function can be used to send request not handled by the library.</p>

<p>The enum <a href="enum.FunctionCode.html"><code>FunctionCode</code></a> provides a list of supported Modbus functions codes, to help
build of raw requests.</p>

<h1 id='parameters-16' class='section-header'><a href='#parameters-16'>Parameters</a></h1>
<ul>
<li><code>raw_request</code>   - raw request to send</li>
</ul>

<h1 id='return-value-21' class='section-header'><a href='#return-value-21'>Return value</a></h1>
<p>The function returns a Result, containing the full message lenght,  counting the extra data relating to the
backend, if successful. Or an Error.</p>

<h1 id='examples-25' class='section-header'><a href='#examples-25'>Examples</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">libmodbus_rs</span>::{<span class="ident">Modbus</span>, <span class="ident">ModbusClient</span>, <span class="ident">ModbusTCP</span>, <span class="ident">FunctionCode</span>};
<span class="kw">let</span> <span class="ident">modbus</span> <span class="op">=</span> <span class="ident">Modbus</span>::<span class="ident">new_tcp</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">1502</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">raw_request</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="number">0xFF</span>, <span class="ident">FunctionCode</span>::<span class="ident">ReadHoldingRegisters</span> <span class="kw">as</span> <span class="ident">u8</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x0</span>, <span class="number">0x05</span>];

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">modbus</span>.<span class="ident">send_raw_request</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">raw_request</span>).<span class="ident">unwrap</span>(), <span class="number">12</span>);
<span class="kw">let</span> <span class="ident">response</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">modbus</span>.<span class="ident">receive_confirmation</span>().<span class="ident">unwrap</span>();</pre>
</div><h4 id='method.receive_confirmation' class="method"><span id='receive_confirmation.v' class='invisible'><code>fn <a href='../libmodbus_rs/trait.ModbusClient.html#tymethod.receive_confirmation' class='fnname'>receive_confirmation</a>(&amp;self) -&gt; <a class="type" href="../libmodbus_rs/errors/type.Result.html" title="type libmodbus_rs::errors::Result">Result</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>&gt;&gt;</code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/libmodbus_rs/modbus_client.rs.html#526-537' title='goto source code'>[src]</a></span></h4>
<div class='docblock'><p><code>receive_confirmation</code> - receive a confirmation request</p>

<p>The <a href="#method.receive_confirmation"><code>receive_confirmation()</code></a> function shall receive a request via the socket of
the context ctx Member of the <a href="struct.Modbus.html">Modbus struct</a>.
This function must be used for debugging purposes because the received response isn’t checked against the
initial request.
This function can be used to receive request not handled by the library.</p>

<p>The maximum size of the response depends on the used backend,
in RTU the rsp array must be MODBUS_RTU_MAX_ADU_LENGTH bytes and in TCP it must be MODBUS_TCP_MAX_ADU_LENGTH
bytes.
If you want to write code compatible with both, you can use the constant MODBUS_MAX_ADU_LENGTH (maximum value
of all libmodbus backends).
Take care to allocate enough memory to store responses to avoid crashes of your server.</p>

<h1 id='return-value-22' class='section-header'><a href='#return-value-22'>Return value</a></h1>
<p>The function returns a Result containing the response length if successful, or an Error.
The returned request length can be zero if the indication request is ignored (eg. a query for another slave in
RTU mode).</p>

<h1 id='parameters-17' class='section-header'><a href='#parameters-17'>Parameters</a></h1>
<ul>
<li><code>response</code>   - store for the received response</li>
</ul>

<h1 id='examples-26' class='section-header'><a href='#examples-26'>Examples</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">libmodbus_rs</span>::{<span class="ident">Modbus</span>, <span class="ident">ModbusClient</span>, <span class="ident">ModbusTCP</span>};
<span class="kw">let</span> <span class="ident">modbus</span> <span class="op">=</span> <span class="ident">Modbus</span>::<span class="ident">new_tcp</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">1502</span>).<span class="ident">unwrap</span>();

<span class="kw">let</span> <span class="ident">response</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">modbus</span>.<span class="ident">receive_confirmation</span>().<span class="ident">unwrap</span>();</pre>
</div></div><h3 id='impl-ModbusRTU' class='impl'><span class='in-band'><code>impl <a class="trait" href="../libmodbus_rs/trait.ModbusRTU.html" title="trait libmodbus_rs::ModbusRTU">ModbusRTU</a> for <a class="struct" href="../libmodbus_rs/struct.Modbus.html" title="struct libmodbus_rs::Modbus">Modbus</a></code><a href='#impl-ModbusRTU' class='anchor'></a></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/libmodbus_rs/modbus_rtu.rs.html#68-347' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.new_rtu' class="method"><span id='new_rtu.v' class='invisible'><code>fn <a href='../libmodbus_rs/trait.ModbusRTU.html#tymethod.new_rtu' class='fnname'>new_rtu</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;device: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;baud: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i32.html">i32</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;parity: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.char.html">char</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;data_bit: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i32.html">i32</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;stop_bit: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i32.html">i32</a><br>) -&gt; <a class="type" href="../libmodbus_rs/errors/type.Result.html" title="type libmodbus_rs::errors::Result">Result</a>&lt;<a class="struct" href="../libmodbus_rs/struct.Modbus.html" title="struct libmodbus_rs::Modbus">Modbus</a>&gt;</code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/libmodbus_rs/modbus_rtu.rs.html#104-119' title='goto source code'>[src]</a></span></h4>
<div class='docblock'><p><code>new_rtu</code> - create a libmodbus context for RTU</p>

<p>The <a href="#method.new_rtu"><code>new_rtu()</code></a> function shall allocate and initialize a structure
to communicate in RTU mode on a serial line.</p>

<p>The <strong>device</strong> argument specifies the name of the serial port handled by the OS, eg. &quot;/dev/ttyS0&quot; or
&quot;/dev/ttyUSB0&quot;.
On Windows, it’s necessary to prepend COM name with &quot;\.&quot; for COM number greater than 9,
eg. &quot;\\.\COM10&quot;. See <a href="http://msdn.microsoft.com/en-us/library/aa365247(v=vs.85).aspx">http://msdn.microsoft.com/en-us/library/aa365247(v=vs.85).aspx</a> for details
The <strong>baud</strong> argument specifies the baud rate of the communication, eg. 9600, 19200, 57600, 115200, etc.</p>

<p>The <strong>parity</strong> argument can have one of the following values:
    * N for none
    * E for even
    * O for odd</p>

<p>The <strong>data_bits argument</strong> specifies the number of bits of data, the allowed values are 5, 6, 7 and 8.
   The <strong>stop_bits</strong> argument specifies the bits of stop, the allowed values are 1 and 2.
   Once the modbus structure is initialized, you must set the slave of your device with
   <a href="#method.set_slave"><code>set_slave()</code></a> and connect to the serial bus with <a href="#method.connect"><code>connect()</code></a>.</p>

<h1 id='examples-27' class='section-header'><a href='#examples-27'>Examples</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">libmodbus_rs</span>::{<span class="ident">Modbus</span>, <span class="ident">ModbusRTU</span>};

<span class="kw">const</span> <span class="ident">YOUR_DEVICE_ID</span>: <span class="ident">u8</span> <span class="op">=</span> <span class="number">1</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">modbus</span> <span class="op">=</span> <span class="ident">Modbus</span>::<span class="ident">new_rtu</span>(<span class="string">&quot;/dev/ttyUSB0&quot;</span>, <span class="number">115200</span>, <span class="string">&#39;N&#39;</span>, <span class="number">8</span>, <span class="number">1</span>).<span class="ident">unwrap</span>();
<span class="ident">modbus</span>.<span class="ident">set_slave</span>(<span class="ident">YOUR_DEVICE_ID</span>);

<span class="kw">match</span> <span class="ident">modbus</span>.<span class="ident">connect</span>() {
    <span class="prelude-val">Ok</span>(_) <span class="op">=&gt;</span> {  }
    <span class="prelude-val">Err</span>(<span class="ident">e</span>) <span class="op">=&gt;</span> <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;Error: {}&quot;</span>, <span class="ident">e</span>),
}</pre>
</div><h4 id='method.rtu_get_serial_mode' class="method"><span id='rtu_get_serial_mode.v' class='invisible'><code>fn <a href='../libmodbus_rs/trait.ModbusRTU.html#tymethod.rtu_get_serial_mode' class='fnname'>rtu_get_serial_mode</a>(&amp;self) -&gt; <a class="type" href="../libmodbus_rs/errors/type.Result.html" title="type libmodbus_rs::errors::Result">Result</a>&lt;<a class="enum" href="../libmodbus_rs/enum.SerialMode.html" title="enum libmodbus_rs::SerialMode">SerialMode</a>&gt;</code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/libmodbus_rs/modbus_rtu.rs.html#151-160' title='goto source code'>[src]</a></span></h4>
<div class='docblock'><p><code>rtu_get_serial_mode</code> - get the current serial mode</p>

<p>The <a href="#method.rtu_get_serial_mode"><code>rtu_get_serial_mode()</code></a> function shall return the serial mode currently
used by the libmodbus context:</p>

<p><code>SerialMode::RtuRS232</code>
    the serial line is set for RS232 communication. RS-232 (Recommended Standard 232)
    is the traditional name for a series of standards for serial binary single-ended
    data and control signals connecting between a DTE (Data Terminal Equipment) and a
    DCE (Data Circuit-terminating Equipment). It is commonly used in computer serial ports</p>

<p><code>SerialMode::RtuRS485</code>
    the serial line is set for RS485 communication.
    EIA-485, also known as TIA/EIA-485 or RS-485, is a standard defining the electrical
    characteristics of drivers and receivers for use in balanced digital multipoint systems.
    This standard is widely used for communications in industrial automation because it can be
    used effectively over long distances and in electrically noisy environments.</p>

<p>This function is only available on Linux kernels 2.6.28 onwards
and can only be used with a context using a RTU backend.</p>

<h1 id='examples-28' class='section-header'><a href='#examples-28'>Examples</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">libmodbus_rs</span>::{<span class="ident">Modbus</span>, <span class="ident">ModbusRTU</span>, <span class="ident">SerialMode</span>};

<span class="kw">let</span> <span class="ident">modbus</span> <span class="op">=</span> <span class="ident">Modbus</span>::<span class="ident">new_rtu</span>(<span class="string">&quot;/dev/ttyUSB0&quot;</span>, <span class="number">115200</span>, <span class="string">&#39;N&#39;</span>, <span class="number">8</span>, <span class="number">1</span>).<span class="ident">unwrap</span>();

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">modbus</span>.<span class="ident">rtu_get_serial_mode</span>().<span class="ident">unwrap</span>(), <span class="ident">SerialMode</span>::<span class="ident">RtuRS232</span>);</pre>
</div><h4 id='method.rtu_set_serial_mode' class="method"><span id='rtu_set_serial_mode.v' class='invisible'><code>fn <a href='../libmodbus_rs/trait.ModbusRTU.html#tymethod.rtu_set_serial_mode' class='fnname'>rtu_set_serial_mode</a>(&amp;mut self, mode: <a class="enum" href="../libmodbus_rs/enum.SerialMode.html" title="enum libmodbus_rs::SerialMode">SerialMode</a>) -&gt; <a class="type" href="../libmodbus_rs/errors/type.Result.html" title="type libmodbus_rs::errors::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">()</a>&gt;</code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/libmodbus_rs/modbus_rtu.rs.html#194-203' title='goto source code'>[src]</a></span></h4>
<div class='docblock'><p><code>rtu_set_serial_mode</code> - set the serial mode</p>

<p>The <a href="#method.rtu_set_serial_mode"><code>rtu_set_serial_mode()</code></a> function shall set the selected serial mode:</p>

<p><code>RTU_RS232</code>
    the serial line is set for RS232 communication.
    RS-232 (Recommended Standard 232) is the traditional name for a series of
    standards for serial binary single-ended data and control signals connecting
    between a DTE (Data Terminal Equipment) and a DCE (Data Circuit-terminating Equipment).
    It is commonly used in computer serial ports</p>

<p><code>RTU_RS485</code>
    the serial line is set for RS485 communication.
    EIA-485, also known as TIA/EIA-485 or RS-485, is a standard defining the
    electrical characteristics of drivers and receivers for use in balanced digital multipoint systems.
    This standard is widely used for communications in industrial automation
    because it can be used effectively over long distances and in electrically noisy environments.</p>

<p>This function is only supported on Linux kernels 2.6.28 onwards.</p>

<h1 id='return-value-23' class='section-header'><a href='#return-value-23'>Return value</a></h1>
<p>The function return an OK Result if successful. Otherwise it contains an Error.</p>

<h1 id='examples-29' class='section-header'><a href='#examples-29'>Examples</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">libmodbus_rs</span>::{<span class="ident">Modbus</span>, <span class="ident">ModbusRTU</span>, <span class="ident">SerialMode</span>};
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">modbus</span> <span class="op">=</span> <span class="ident">Modbus</span>::<span class="ident">new_rtu</span>(<span class="string">&quot;/dev/ttyUSB0&quot;</span>, <span class="number">115200</span>, <span class="string">&#39;N&#39;</span>, <span class="number">8</span>, <span class="number">1</span>).<span class="ident">unwrap</span>();

<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">modbus</span>.<span class="ident">rtu_set_serial_mode</span>(<span class="ident">SerialMode</span>::<span class="ident">RtuRS232</span>).<span class="ident">is_ok</span>());</pre>
</div><h4 id='method.rtu_set_rts' class="method"><span id='rtu_set_rts.v' class='invisible'><code>fn <a href='../libmodbus_rs/trait.ModbusRTU.html#tymethod.rtu_set_rts' class='fnname'>rtu_set_rts</a>(&amp;mut self, mode: <a class="enum" href="../libmodbus_rs/enum.RequestToSendMode.html" title="enum libmodbus_rs::RequestToSendMode">RequestToSendMode</a>) -&gt; <a class="type" href="../libmodbus_rs/errors/type.Result.html" title="type libmodbus_rs::errors::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">()</a>&gt;</code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/libmodbus_rs/modbus_rtu.rs.html#232-240' title='goto source code'>[src]</a></span></h4>
<div class='docblock'><p><code>rtu_set_rts</code> - set the RTS mode in RTU</p>

<p>The <a href="#method.rtu_set_rts"><code>rtu_set_rts()</code></a> function shall set the Request To Send mode to communicate on a
RS485 serial bus.
By default, the mode is set to <code>RequestToSendMode::RtuRtsNone</code> and no signal is issued before writing
data on the wire.</p>

<p>To enable the RTS mode, the values <code>RequestToSendMode::RtuRtsUp</code> or
<code>RequestToSendMode::RtuRtsDown</code> must be used,
these modes enable the RTS mode and set the polarity at the same time. When
<code>RequestToSendMode::RtuRtsUp</code> is used,
an ioctl call is made with RTS flag enabled then data is written on the bus after a delay of 1 ms,
then another ioctl call is made with the RTS flag disabled and again a delay of 1 ms occurs.
The <code>RequestToSendMode::RtuRtsDown</code> mode applies the same procedure but with an inverted RTS flag.</p>

<p>This function can only be used with a context using a RTU backend.</p>

<h1 id='examples-30' class='section-header'><a href='#examples-30'>Examples</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">libmodbus_rs</span>::{<span class="ident">Modbus</span>, <span class="ident">ModbusRTU</span>, <span class="ident">SerialMode</span>, <span class="ident">RequestToSendMode</span>};
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">modbus</span> <span class="op">=</span> <span class="ident">Modbus</span>::<span class="ident">new_rtu</span>(<span class="string">&quot;/dev/ttyUSB0&quot;</span>, <span class="number">115200</span>, <span class="string">&#39;N&#39;</span>, <span class="number">8</span>, <span class="number">1</span>).<span class="ident">unwrap</span>();

<span class="kw">let</span> <span class="ident">serial_mode</span> <span class="op">=</span> <span class="ident">modbus</span>.<span class="ident">rtu_set_serial_mode</span>(<span class="ident">SerialMode</span>::<span class="ident">RtuRS485</span>);

<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">modbus</span>.<span class="ident">rtu_set_rts</span>(<span class="ident">RequestToSendMode</span>::<span class="ident">RtuRtsUp</span>).<span class="ident">is_ok</span>());</pre>
</div><h4 id='method.rtu_get_rts' class="method"><span id='rtu_get_rts.v' class='invisible'><code>fn <a href='../libmodbus_rs/trait.ModbusRTU.html#tymethod.rtu_get_rts' class='fnname'>rtu_get_rts</a>(&amp;self) -&gt; <a class="type" href="../libmodbus_rs/errors/type.Result.html" title="type libmodbus_rs::errors::Result">Result</a>&lt;<a class="enum" href="../libmodbus_rs/enum.RequestToSendMode.html" title="enum libmodbus_rs::RequestToSendMode">RequestToSendMode</a>&gt;</code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/libmodbus_rs/modbus_rtu.rs.html#260-270' title='goto source code'>[src]</a></span></h4>
<div class='docblock'><p><code>rtu_get_rts</code> -  get the current RTS mode in RTU</p>

<p>The <a href="#method.rtu_get_rts"><code>rtu_get_rts()</code></a> function shall get the current Request To Send mode of the libmodbus
context ctx. The possible returned values are:
    * MODBUS_RTU_RTS_NONE
    * MODBUS_RTU_RTS_UP
    * MODBUS_RTU_RTS_DOWN</p>

<p>This function can only be used with a context using a RTU backend.</p>

<h1 id='examples-31' class='section-header'><a href='#examples-31'>Examples</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">libmodbus_rs</span>::{<span class="ident">Modbus</span>, <span class="ident">ModbusRTU</span>, <span class="ident">SerialMode</span>};
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">modbus</span> <span class="op">=</span> <span class="ident">Modbus</span>::<span class="ident">new_rtu</span>(<span class="string">&quot;/dev/ttyUSB0&quot;</span>, <span class="number">115200</span>, <span class="string">&#39;N&#39;</span>, <span class="number">8</span>, <span class="number">1</span>).<span class="ident">unwrap</span>();

<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">modbus</span>.<span class="ident">rtu_set_serial_mode</span>(<span class="ident">SerialMode</span>::<span class="ident">RtuRS485</span>).<span class="ident">is_ok</span>());</pre>
</div><h4 id='method.rtu_set_custom_rts' class="method"><span id='rtu_set_custom_rts.v' class='invisible'><code>fn <a href='../libmodbus_rs/trait.ModbusRTU.html#tymethod.rtu_set_custom_rts' class='fnname'>rtu_set_custom_rts</a>(&amp;mut self, _mode: <a class="enum" href="../libmodbus_rs/enum.RequestToSendMode.html" title="enum libmodbus_rs::RequestToSendMode">RequestToSendMode</a>) -&gt; <a class="type" href="../libmodbus_rs/errors/type.Result.html" title="type libmodbus_rs::errors::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i32.html">i32</a>&gt;</code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/libmodbus_rs/modbus_rtu.rs.html#284-286' title='goto source code'>[src]</a></span></h4>
<div class='docblock'><p><code>rtu_set_custom_rts</code> - set a function to be used for custom RTS implementation</p>

<p>The modbus_rtu_set_custom_rts() function shall set a custom function to be called when the RTS pin is to be set
before and after a transmission. By default this is set to an internal function that toggles the RTS pin using
an ioctl call.</p>

<p>Note that this function adheres to the RTS mode,
the values MODBUS_RTU_RTS_UP or MODBUS_RTU_RTS_DOWN must be used for the function to be called.</p>

<p>This function can only be used with a context using a RTU backend.</p>

<p>TODO: implement rtu_set_custom_rts()!</p>
</div><h4 id='method.rtu_get_rts_delay' class="method"><span id='rtu_get_rts_delay.v' class='invisible'><code>fn <a href='../libmodbus_rs/trait.ModbusRTU.html#tymethod.rtu_get_rts_delay' class='fnname'>rtu_get_rts_delay</a>(&amp;self) -&gt; <a class="type" href="../libmodbus_rs/errors/type.Result.html" title="type libmodbus_rs::errors::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i32.html">i32</a>&gt;</code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/libmodbus_rs/modbus_rtu.rs.html#309-316' title='goto source code'>[src]</a></span></h4>
<div class='docblock'><p><code>rtu_get_rts_delay</code> - get the current RTS delay in RTU</p>

<p>The <a href="#method.rtu_get_rts_delay"><code>rtu_get_rts_delay()</code></a> function shall get the current
Request To Send  delay period of the libmodbus context ctx.</p>

<p>This function can only be used with a context using a RTU backend.</p>

<h1 id='return-value-24' class='section-header'><a href='#return-value-24'>Return value</a></h1>
<p>The <a href="#method.rtu_get_rts_delay"><code>rtu_get_rts_delay()</code></a> function shall return the current RTS delay in
microseconds
if successful. Otherwise it shall return <code>ModbusError::NotRTU</code>.</p>

<h1 id='examples-32' class='section-header'><a href='#examples-32'>Examples</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">libmodbus_rs</span>::{<span class="ident">Modbus</span>, <span class="ident">ModbusRTU</span>};
<span class="kw">let</span> <span class="ident">modbus</span> <span class="op">=</span> <span class="ident">Modbus</span>::<span class="ident">new_rtu</span>(<span class="string">&quot;/dev/ttyUSB0&quot;</span>, <span class="number">115200</span>, <span class="string">&#39;N&#39;</span>, <span class="number">8</span>, <span class="number">1</span>).<span class="ident">unwrap</span>();

<span class="ident">modbus</span>.<span class="ident">rtu_get_rts_delay</span>();</pre>
</div><h4 id='method.rtu_set_rts_delay' class="method"><span id='rtu_set_rts_delay.v' class='invisible'><code>fn <a href='../libmodbus_rs/trait.ModbusRTU.html#tymethod.rtu_set_rts_delay' class='fnname'>rtu_set_rts_delay</a>(&amp;mut self, us: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i32.html">i32</a>) -&gt; <a class="type" href="../libmodbus_rs/errors/type.Result.html" title="type libmodbus_rs::errors::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">()</a>&gt;</code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/libmodbus_rs/modbus_rtu.rs.html#338-346' title='goto source code'>[src]</a></span></h4>
<div class='docblock'><p><code>rtu_set_rts_delay</code> - get the current RTS delay in RTU</p>

<p>The <a href="#method.rtu_set_rts_delay"><code>rtu_set_rts_delay()</code></a> function shall set the Request To Send delay period of
the libmodbus context.</p>

<p>This function can only be used with a context using a RTU backend.</p>

<h1 id='return-value-25' class='section-header'><a href='#return-value-25'>Return value</a></h1>
<p>The <a href="#method.rtu_set_rts_delay"><code>rtu_set_rts_delay()</code></a> function return an OK Result if successful. Otherwise it
contains an Error.</p>

<h1 id='examples-33' class='section-header'><a href='#examples-33'>Examples</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">libmodbus_rs</span>::{<span class="ident">Modbus</span>, <span class="ident">ModbusRTU</span>};
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">modbus</span> <span class="op">=</span> <span class="ident">Modbus</span>::<span class="ident">new_rtu</span>(<span class="string">&quot;/dev/ttyUSB0&quot;</span>, <span class="number">115200</span>, <span class="string">&#39;N&#39;</span>, <span class="number">8</span>, <span class="number">1</span>).<span class="ident">unwrap</span>();

<span class="kw">let</span> _ <span class="op">=</span> <span class="ident">modbus</span>.<span class="ident">rtu_set_rts_delay</span>(<span class="number">100</span>).<span class="ident">unwrap</span>();</pre>
</div></div><h3 id='impl-ModbusServer' class='impl'><span class='in-band'><code>impl <a class="trait" href="../libmodbus_rs/trait.ModbusServer.html" title="trait libmodbus_rs::ModbusServer">ModbusServer</a> for <a class="struct" href="../libmodbus_rs/struct.Modbus.html" title="struct libmodbus_rs::Modbus">Modbus</a></code><a href='#impl-ModbusServer' class='anchor'></a></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/libmodbus_rs/modbus_server.rs.html#21-83' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.receive' class="method"><span id='receive.v' class='invisible'><code>fn <a href='../libmodbus_rs/trait.ModbusServer.html#tymethod.receive' class='fnname'>receive</a>(&amp;self, request: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;mut [</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>) -&gt; <a class="type" href="../libmodbus_rs/errors/type.Result.html" title="type libmodbus_rs::errors::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i32.html">i32</a>&gt;</code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/libmodbus_rs/modbus_server.rs.html#41-51' title='goto source code'>[src]</a></span></h4>
<div class='docblock'><p><code>receive</code> - receive an indication request</p>

<p>The <a href="#method.receive"><code>receive()</code></a> function shall receive an indication request from the socket of the context
ctx.
This function is used by Modbus slave/server to receive and analyze indication request sent by the
masters/clients.</p>

<p>If you need to use another socket or file descriptor than the one defined in the context ctx, see the function
<a href="struct.Modbus.html#method.set_socket"><code>set_socket()</code></a>.</p>

<h1 id='examples-34' class='section-header'><a href='#examples-34'>Examples</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">libmodbus_rs</span>::{<span class="ident">Modbus</span>, <span class="ident">ModbusServer</span>, <span class="ident">ModbusTCP</span>};
<span class="kw">let</span> <span class="ident">modbus</span> <span class="op">=</span> <span class="ident">Modbus</span>::<span class="ident">new_tcp</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">1502</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">query</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="number">0</span>; <span class="ident">Modbus</span>::<span class="ident">MAX_ADU_LENGTH</span> <span class="kw">as</span> <span class="ident">usize</span>];

<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">modbus</span>.<span class="ident">receive</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">query</span>).<span class="ident">is_ok</span>());</pre>
</div><h4 id='method.reply' class="method"><span id='reply.v' class='invisible'><code>fn <a href='../libmodbus_rs/trait.ModbusServer.html#tymethod.reply' class='fnname'>reply</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;request: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;request_len: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i32.html">i32</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;modbus_mapping: &amp;<a class="struct" href="../libmodbus_rs/struct.ModbusMapping.html" title="struct libmodbus_rs::ModbusMapping">ModbusMapping</a><br>) -&gt; <a class="type" href="../libmodbus_rs/errors/type.Result.html" title="type libmodbus_rs::errors::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i32.html">i32</a>&gt;</code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/libmodbus_rs/modbus_server.rs.html#73-82' title='goto source code'>[src]</a></span></h4>
<div class='docblock'><p><code>modbus_reply</code> - send a reponse to the received request</p>

<p>The <a href="#method.reply"><code>reply()</code></a> function shall send a response to received request. The request req given in
argument is analyzed, a response is then built and sent by using the information of the modbus context ctx.
If the request indicates to read or write a value the operation will done in the modbus mapping mb_mapping
according to the type of the manipulated data.
If an error occurs, an exception response will be sent.</p>

<p>This function is designed for Modbus server.</p>

<h1 id='examples-35' class='section-header'><a href='#examples-35'>Examples</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">libmodbus_rs</span>::{<span class="ident">Modbus</span>, <span class="ident">ModbusServer</span>, <span class="ident">ModbusTCP</span>};

<span class="kw">let</span> <span class="ident">modbus</span> <span class="op">=</span> <span class="ident">Modbus</span>::<span class="ident">new_tcp</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">1502</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">query</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="number">0</span>; <span class="ident">Modbus</span>::<span class="ident">MAX_ADU_LENGTH</span> <span class="kw">as</span> <span class="ident">usize</span>];

<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">modbus</span>.<span class="ident">receive</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">query</span>).<span class="ident">is_ok</span>());</pre>
</div></div><h3 id='impl-ModbusTCPPI' class='impl'><span class='in-band'><code>impl <a class="trait" href="../libmodbus_rs/trait.ModbusTCPPI.html" title="trait libmodbus_rs::ModbusTCPPI">ModbusTCPPI</a> for <a class="struct" href="../libmodbus_rs/struct.Modbus.html" title="struct libmodbus_rs::Modbus">Modbus</a></code><a href='#impl-ModbusTCPPI' class='anchor'></a></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/libmodbus_rs/modbus_tcp_pi.rs.html#24-134' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.new_tcp_pi' class="method"><span id='new_tcp_pi.v' class='invisible'><code>fn <a href='../libmodbus_rs/trait.ModbusTCPPI.html#tymethod.new_tcp_pi' class='fnname'>new_tcp_pi</a>(node: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>, service: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>) -&gt; <a class="type" href="../libmodbus_rs/errors/type.Result.html" title="type libmodbus_rs::errors::Result">Result</a>&lt;<a class="struct" href="../libmodbus_rs/struct.Modbus.html" title="struct libmodbus_rs::Modbus">Modbus</a>&gt;</code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/libmodbus_rs/modbus_tcp_pi.rs.html#51-63' title='goto source code'>[src]</a></span></h4>
<div class='docblock'><p><code>new_tcp_pi</code> - create a libmodbus context for TCP Protocol Independent</p>

<p>The <a href="#method.new_tcp_pi"><code>new_tcp_pi()</code></a> function shall allocate and initialize a modbus_t structure to
communicate with a Modbus TCP IPv4 or IPv6 server.</p>

<p>The <strong>node</strong> argument specifies the host name or IP address of the host to connect to, eg. &quot;192.168.0.5&quot; ,
&quot;::1&quot; or &quot;server.com&quot;.
A NULL value can be used to listen any addresses in server mode.</p>

<p>The <strong>service</strong> argument is the service name/port number to connect to. To use the default Modbus port use the
string &quot;502&quot;.
On many Unix systems, it’s convenient to use a port number greater than or equal to 1024 because it’s not
necessary to have administrator privileges.</p>

<h1 id='examples-36' class='section-header'><a href='#examples-36'>Examples</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">libmodbus_rs</span>::{<span class="ident">Modbus</span>, <span class="ident">ModbusTCPPI</span>};

<span class="kw">let</span> <span class="ident">modbus</span> <span class="op">=</span> <span class="ident">Modbus</span>::<span class="ident">new_tcp_pi</span>(<span class="string">&quot;::1&quot;</span>, <span class="string">&quot;1502&quot;</span>).<span class="ident">unwrap</span>();

<span class="kw">match</span> <span class="ident">modbus</span>.<span class="ident">connect</span>() {
    <span class="prelude-val">Ok</span>(_) <span class="op">=&gt;</span> {}
    <span class="prelude-val">Err</span>(<span class="ident">e</span>) <span class="op">=&gt;</span> <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;Error: {}&quot;</span>, <span class="ident">e</span>),
}</pre>
</div><h4 id='method.tcp_pi_accept' class="method"><span id='tcp_pi_accept.v' class='invisible'><code>fn <a href='../libmodbus_rs/trait.ModbusTCPPI.html#tymethod.tcp_pi_accept' class='fnname'>tcp_pi_accept</a>(&amp;mut self, socket: &amp;mut <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i32.html">i32</a>) -&gt; <a class="type" href="../libmodbus_rs/errors/type.Result.html" title="type libmodbus_rs::errors::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i32.html">i32</a>&gt;</code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/libmodbus_rs/modbus_tcp_pi.rs.html#83-90' title='goto source code'>[src]</a></span></h4>
<div class='docblock'><p><code>tcp_pi_accept</code> - accept a new connection on a TCP PI Modbus socket (IPv6)</p>

<p>The <a href="#method.tcp_pi_accept"><code>tcp_pi_accept()</code></a> function shall extract the first connection on the
queue of pending connections and create a new socket given as argument.</p>

<h1 id='parameters-18' class='section-header'><a href='#parameters-18'>Parameters</a></h1>
<ul>
<li><code>socket</code>  - Socket</li>
</ul>

<h1 id='examples-37' class='section-header'><a href='#examples-37'>Examples</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">libmodbus_rs</span>::{<span class="ident">Modbus</span>, <span class="ident">ModbusMapping</span>, <span class="ident">ModbusServer</span>, <span class="ident">ModbusTCPPI</span>};

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">modbus</span> <span class="op">=</span> <span class="ident">Modbus</span>::<span class="ident">new_tcp_pi</span>(<span class="string">&quot;::0&quot;</span>, <span class="string">&quot;1502&quot;</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">socket</span> <span class="op">=</span> <span class="ident">modbus</span>.<span class="ident">tcp_pi_listen</span>(<span class="number">1</span>).<span class="ident">unwrap</span>();
<span class="ident">modbus</span>.<span class="ident">tcp_pi_accept</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">socket</span>).<span class="ident">unwrap</span>();</pre>
</div><h4 id='method.tcp_pi_listen' class="method"><span id='tcp_pi_listen.v' class='invisible'><code>fn <a href='../libmodbus_rs/trait.ModbusTCPPI.html#tymethod.tcp_pi_listen' class='fnname'>tcp_pi_listen</a>(&amp;mut self, num_connection: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i32.html">i32</a>) -&gt; <a class="type" href="../libmodbus_rs/errors/type.Result.html" title="type libmodbus_rs::errors::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i32.html">i32</a>&gt;</code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/libmodbus_rs/modbus_tcp_pi.rs.html#126-133' title='goto source code'>[src]</a></span></h4>
<div class='docblock'><p><code>tcp_pi_listen</code> - create and listen a TCP PI Modbus socket (IPv6)</p>

<p>The <a href="#method.tcp_pi_listen"><code>tcp_pi_listen()</code></a> function shall create a socket and listen to maximum
<code>num_connection</code> incoming connections on the specifieded node.</p>

<h1 id='parameters-19' class='section-header'><a href='#parameters-19'>Parameters</a></h1>
<ul>
<li><code>num_connection</code>  - maximum number of incoming connections on the specified IP address</li>
</ul>

<p>If node is set to <code>&quot;&quot;</code> or <code>0.0.0.0</code>, any addresses will be listen.</p>

<h1 id='examples-38' class='section-header'><a href='#examples-38'>Examples</a></h1>
<p>For detailed examples, look at the examples directory of this crate.</p>

<ul>
<li>unit-test-server.rs   - simple but handle only one connection</li>
<li>bandwidth-server-many-up.rs   - handles several connection at once</li>
</ul>

<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">libmodbus_rs</span>::{<span class="ident">Modbus</span>, <span class="ident">ModbusMapping</span>, <span class="ident">ModbusServer</span>, <span class="ident">ModbusTCPPI</span>};

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">modbus</span> <span class="op">=</span> <span class="ident">Modbus</span>::<span class="ident">new_tcp_pi</span>(<span class="string">&quot;::0&quot;</span>, <span class="string">&quot;1502&quot;</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">socket</span> <span class="op">=</span> <span class="ident">modbus</span>.<span class="ident">tcp_pi_listen</span>(<span class="number">1</span>).<span class="ident">unwrap</span>();

<span class="ident">modbus</span>.<span class="ident">tcp_pi_accept</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">socket</span>);

<span class="kw">let</span> <span class="ident">modbus_mapping</span> <span class="op">=</span> <span class="ident">ModbusMapping</span>::<span class="ident">new</span>(<span class="number">500</span>, <span class="number">500</span>, <span class="number">500</span>, <span class="number">500</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">query</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="number">0u8</span>; <span class="ident">Modbus</span>::<span class="ident">MAX_ADU_LENGTH</span> <span class="kw">as</span> <span class="ident">usize</span>];

<span class="kw">loop</span> {
    <span class="kw">let</span> <span class="ident">request_len</span> <span class="op">=</span> <span class="ident">modbus</span>.<span class="ident">receive</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">query</span>).<span class="ident">unwrap</span>();
    <span class="ident">modbus</span>.<span class="ident">reply</span>(<span class="kw-2">&amp;</span><span class="ident">query</span>, <span class="ident">request_len</span>, <span class="kw-2">&amp;</span><span class="ident">modbus_mapping</span>);
}</pre>
</div></div><h3 id='impl-ModbusTCP' class='impl'><span class='in-band'><code>impl <a class="trait" href="../libmodbus_rs/trait.ModbusTCP.html" title="trait libmodbus_rs::ModbusTCP">ModbusTCP</a> for <a class="struct" href="../libmodbus_rs/struct.Modbus.html" title="struct libmodbus_rs::Modbus">Modbus</a></code><a href='#impl-ModbusTCP' class='anchor'></a></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/libmodbus_rs/modbus_tcp.rs.html#20-113' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.new_tcp' class="method"><span id='new_tcp.v' class='invisible'><code>fn <a href='../libmodbus_rs/trait.ModbusTCP.html#tymethod.new_tcp' class='fnname'>new_tcp</a>(ip: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>, port: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i32.html">i32</a>) -&gt; <a class="type" href="../libmodbus_rs/errors/type.Result.html" title="type libmodbus_rs::errors::Result">Result</a>&lt;<a class="struct" href="../libmodbus_rs/struct.Modbus.html" title="struct libmodbus_rs::Modbus">Modbus</a>&gt;</code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/libmodbus_rs/modbus_tcp.rs.html#44-55' title='goto source code'>[src]</a></span></h4>
<div class='docblock'><p><code>new_tcp</code> - create a libmodbus context for TCP/IPv4</p>

<p>The <a href="#method.new_tcp"><code>new_tcp()</code></a> function shall allocate and initialize a modbus_t structure
to communicate with a Modbus TCP IPv4 server.
The <strong>ip</strong> argument specifies the IP address of the server to which the client wants to
establish a connection. A empty string <code>&quot;&quot;</code> value can be used to listen any addresses in server mode.
The <strong>port</strong> argument is the TCP port to use. Set the port to <code>MODBUS_TCP_DEFAULT_PORT</code>
to use the default one (502). It’s convenient to use a port number greater than or
equal to 1024 because it’s not necessary to have administrator privileges.</p>

<h1 id='examples-39' class='section-header'><a href='#examples-39'>Examples</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">libmodbus_rs</span>::{<span class="ident">Modbus</span>, <span class="ident">ModbusTCP</span>};

<span class="kw">let</span> <span class="ident">modbus</span> <span class="op">=</span> <span class="ident">Modbus</span>::<span class="ident">new_tcp</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">1502</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">modbus</span> <span class="op">=</span> <span class="ident">Modbus</span>::<span class="ident">new_tcp</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="ident">Modbus</span>::<span class="ident">TCP_DEFAULT_PORT</span> <span class="kw">as</span> <span class="ident">i32</span>).<span class="ident">unwrap</span>();

<span class="kw">match</span> <span class="ident">modbus</span>.<span class="ident">connect</span>() {
    <span class="prelude-val">Ok</span>(_) <span class="op">=&gt;</span> {  }
    <span class="prelude-val">Err</span>(<span class="ident">e</span>) <span class="op">=&gt;</span> <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;Error: {}&quot;</span>, <span class="ident">e</span>),
}</pre>
</div><h4 id='method.tcp_accept' class="method"><span id='tcp_accept.v' class='invisible'><code>fn <a href='../libmodbus_rs/trait.ModbusTCP.html#tymethod.tcp_accept' class='fnname'>tcp_accept</a>(&amp;mut self, socket: &amp;mut <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i32.html">i32</a>) -&gt; <a class="type" href="../libmodbus_rs/errors/type.Result.html" title="type libmodbus_rs::errors::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i32.html">i32</a>&gt;</code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/libmodbus_rs/modbus_tcp.rs.html#76-83' title='goto source code'>[src]</a></span></h4>
<div class='docblock'><p><code>tcp_accept</code> - accept a new connection on a TCP Modbus socket (IPv4)</p>

<p>The <a href="#method.tcp_accept"><code>tcp_accept()</code></a> function shall extract the first connection on the
queue of pending connections and create a new socket given as argument.</p>

<h1 id='parameters-20' class='section-header'><a href='#parameters-20'>Parameters</a></h1>
<ul>
<li><code>socket</code>  - Socket</li>
</ul>

<h1 id='examples-40' class='section-header'><a href='#examples-40'>Examples</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">libmodbus_rs</span>::{<span class="ident">Modbus</span>, <span class="ident">ModbusTCP</span>};

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">modbus</span> <span class="op">=</span> <span class="ident">Modbus</span>::<span class="ident">new_tcp</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">1502</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">socket</span> <span class="op">=</span> <span class="ident">modbus</span>.<span class="ident">tcp_listen</span>(<span class="number">1</span>).<span class="ident">unwrap</span>();

<span class="ident">modbus</span>.<span class="ident">tcp_accept</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">socket</span>);</pre>
</div><h4 id='method.tcp_listen' class="method"><span id='tcp_listen.v' class='invisible'><code>fn <a href='../libmodbus_rs/trait.ModbusTCP.html#tymethod.tcp_listen' class='fnname'>tcp_listen</a>(&amp;mut self, num_connection: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i32.html">i32</a>) -&gt; <a class="type" href="../libmodbus_rs/errors/type.Result.html" title="type libmodbus_rs::errors::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i32.html">i32</a>&gt;</code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/libmodbus_rs/modbus_tcp.rs.html#105-112' title='goto source code'>[src]</a></span></h4>
<div class='docblock'><p><code>tcp_listen</code> - create and listen a TCP Modbus socket (IPv4)</p>

<p>The <a href="#method.tcp_listen"><code>tcp_listen()</code></a> function shall create a socket and listen to maximum
<code>num_connection</code> incoming connections on the specified IP address.
If IP address is set to NULL or &#39;0.0.0.0&#39;, any addresses will be listen.</p>

<h1 id='parameters-21' class='section-header'><a href='#parameters-21'>Parameters</a></h1>
<ul>
<li><code>num_connection</code>  - maximum number of incoming connections on the specified IP address</li>
</ul>

<h1 id='examples-41' class='section-header'><a href='#examples-41'>Examples</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">libmodbus_rs</span>::{<span class="ident">Modbus</span>, <span class="ident">ModbusTCP</span>};

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">modbus</span> <span class="op">=</span> <span class="ident">Modbus</span>::<span class="ident">new_tcp</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">1502</span>).<span class="ident">unwrap</span>();

<span class="kw">let</span> <span class="ident">socket</span> <span class="op">=</span> <span class="ident">modbus</span>.<span class="ident">tcp_listen</span>(<span class="number">1</span>);</pre>
</div></div><h3 id='impl-Drop' class='impl'><span class='in-band'><code>impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/drop/trait.Drop.html" title="trait core::ops::drop::Drop">Drop</a> for <a class="struct" href="../libmodbus_rs/struct.Modbus.html" title="struct libmodbus_rs::Modbus">Modbus</a></code><a href='#impl-Drop' class='anchor'></a></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/libmodbus_rs/modbus.rs.html#912-917' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.drop' class="method"><span id='drop.v' class='invisible'><code>fn <a href='https://doc.rust-lang.org/nightly/core/ops/drop/trait.Drop.html#tymethod.drop' class='fnname'>drop</a>(&amp;mut self)</code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/libmodbus_rs/modbus.rs.html#913-916' title='goto source code'>[src]</a></span></h4>
<div class='docblock'><p>Executes the destructor for this type. <a href="https://doc.rust-lang.org/nightly/core/ops/drop/trait.Drop.html#tymethod.drop">Read more</a></p>
</div></div></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <aside id="help" class="hidden">
        <div>
            <h1 class="hidden">Help</h1>

            <div class="shortcuts">
                <h2>Keyboard Shortcuts</h2>

                <dl>
                    <dt>?</dt>
                    <dd>Show this help dialog</dd>
                    <dt>S</dt>
                    <dd>Focus the search field</dd>
                    <dt>&larrb;</dt>
                    <dd>Move up in search results</dd>
                    <dt>&rarrb;</dt>
                    <dd>Move down in search results</dd>
                    <dt>&#9166;</dt>
                    <dd>Go to active search result</dd>
                    <dt>+</dt>
                    <dd>Collapse/expand all sections</dd>
                </dl>
            </div>

            <div class="infos">
                <h2>Search Tricks</h2>

                <p>
                    Prefix searches with a type followed by a colon (e.g.
                    <code>fn:</code>) to restrict the search to a given type.
                </p>

                <p>
                    Accepted types are: <code>fn</code>, <code>mod</code>,
                    <code>struct</code>, <code>enum</code>,
                    <code>trait</code>, <code>type</code>, <code>macro</code>,
                    and <code>const</code>.
                </p>

                <p>
                    Search functions by type signature (e.g.
                    <code>vec -> usize</code> or <code>* -> vec</code>)
                </p>
            </div>
        </div>
    </aside>

    

    <script>
        window.rootPath = "../";
        window.currentCrate = "libmodbus_rs";
    </script>
    <script src="../main.js"></script>
    <script defer src="../search-index.js"></script>
</body>
</html>